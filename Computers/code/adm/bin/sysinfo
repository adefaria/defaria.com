#!/bin/bash
#
# 
# Title:         sysinfo
# Author:        Scott Truesdale
# Organization:  Hewlett-Packard Account Support Organization 
#                America's Engineering Services Team
#
# NOTE: This script is a contributed utility. No official support for it
#       will be provided by Hewlett-Packard. Any requests for bug fixes
#       or enhancements will be handled by the author, time permitting.
#
# Version:       1.00 08/01/96
# Changes:       1.01 08/05/96 added functions to handle each module
#                1.02          \ cleaned up various 
#                1.03          / output screens
#                1.04 08/20/96 added filesystem check using lvol
#                1.05 08/25/96 added savecore flag and space check
#                1.06 09/03/96 changed filesystem check to use mnttab
#                1.07 09/03/96 fixed filesystem check when bdf is 2 lines
#                1.08 10/10/96 general cleanup, added more dump checking
#                1.09 10/10/96 added use of pager variable for output
#                1.10 10/23/96 fixed dump checking section (I hope)
#                              added 10.10 compression calculation (-s)
#                1.11 10/30/96 fixed display of number of stale extents (-l)
#                              added comments to help document functions.
#                1.12 10/31/96 added -N option to disable paging option.
#                1.13 11/06/96 added cpu speed display (in MHz). (-s)
#                1.14 11/08/96 removed tabs and added comments.
#                1.15 11/11/96 added check for non HP-UX systems.
#                1.16 11/20/96 expanded mapping to include number of
#                              extents and mirrors. (-m)
#                1.17 11/21/96 added kernel size display (-k)
#                              added check for non-LVM disks (-p)
#                1.18 11/26/96 added license, machine id (-s)
#                              added domain name (-k)
#                              fixed batch to include header information
#                              added check for vgcfg files > 1 year old. (-v)
#                              added kernel size to memory dump calculations
#                1.19 12/03/96 fixed error if no CD mounted in CD-ROM drive
#                              changed help (-h) to use man page
#                1.20 12/12/96 added physical disk mapping option (-M)
#                              for 10.x systems
#                              added dbc_max_pct kernel parm
#                1.21 12/17/96 added physical disk mapping for 9.x
#                1.22 01/07/97 fixed bug in path display for cdroms
#                1.23 02/04/97 added last patch date display
#                1.24 02/10/97 fixed bug in physical check for cdrom
#                              device busy error
#                1.25 02/12/97 fixed display of dump on default for 9.x
#                1.26 02/28/97 added display of default router
#                1.27 03/10/97 added display of MAC address
#                1.28 03/18/97 added display of alternate links
#                              added bootable check to Physical info
#                1.29 04/15/97 added check for dynamic buffer caching
#                              added nflocks kernel parm
#                              added check for async disk write
#                              added check for savecore compression in
#                                    /etc/rc.config.d/savecore
#                              fixed exit code for warnings
#                              added auto boot string output
#                1.30 04/22/97 cleaned up swap and dump disk display
#                              added check for cdfs to % full warning
#                              fixed dbc and its warning for only 10.x 
#                              added ability to specify savecore
#                                    compression factor as variable
#                1.31 04/22/97 fixed bug in calculating savecore capacity
#                1.32 04/22/97 added display of boot disks
#                1.33 07/08/97 fixed pre 10.20 warning for not
#                              enough savecore space
#                1.34 07/19/97 added dns server display
#                              changed netmask to decimal.dot format
#                1.35 07/29/97 added use of model command to detect new
#                                    system models
#                              added following from Mike Ryan:
#                                fixed display of multiple MAC addresses
#                                patch for pvdisplay difference in 10.20
#                                fix VG display when PVG-strict policies used
#                                (thanks Mike!)
#                1.36 07/31/97 fixed bug in alternate PV link detection
#                1.37 08/01/97 added super page check
#                              removed dynamic buffer warning
#                              improved debug message handling
#                              changed debug messages to tee to file
#                1.38 08/17/97 added check for number of volume groups equal
#                                to maxvgs
#                              started adding HTML hooks (-H option)
#                                added HTML headers to each section
#                                added HTML links to each section
#                                added HTML info to man page
#                1.39 08/20/97 added check for existing logfiles
#                              ask user if we should delete batch logfile
#                              automatically delete HTML logfile
#                              changed temp file names to sysinfo.$$.
#                1.40 08/26/97 changed physical disk section to not query
#                              alternate links
#                1.41 08/28/97 added kernel parms section extracted using
#                              tools from SAM.
#                1.42 09/19/97 changed network to use lanscan due to
#                              problems with multiple I/F cards.
#                1.43 10/21/97 added hw path to network card info.
#                              added fstype display to filesystem info.
#                              fixed display of cdfs space usage.
#                              fixed man page that incorrectly stated free
#                                space threshold was 10% instead of 5%.
#                1.44 04/09/98 major enhancements
#                                added ioscan listing.
#                                added software listing (10.x only)
#                                added listing of striped discs.
#                                launched io, kernel and lvm scans
#                                  as background jobs to speed things up.
#                1.45 04/17/98 fixed bug that caused dbc parms not to
#                                be displayed.
#                1.46 04/30/98 changed swap disk header to swap data
#                                added fs swaptype to total swap display
#                1.47 05/03/98 added warning about static buffer cache
#                                numbers reported from kernel.
#                1.48 05/20/98 added variable for logfile directory.
#                              removed user query if removing existing logfile.
#                              reworked logical volume section into two parts.
#                1.49 07/01/98 first set of changes to work on 11.x
#                                savecore now called savecrash
#                                changed BOOTABLE to check for >= 10
#                                physmem now called phys_mem_pages
#                1.49a         added host name to WARNING messages
#                              added TOP link to html output
#                1.49b 07/16/98 fixed problems for 9.x induced by background
#                              scans of sam, swap and ioscan
#                                samscan, ioscan, swapmem
#                                removed samscan (getkinfo) from 9.x
#                              changed to force getkinfo to rescan (-b)
#                1.49c 07/23/98  more ioscan changes for 9.x
#                1.49d 07/27/98 major kernel changes
#                1.49e 08/01/98 fixed problem with filesystem display 
#                                  if size greater than 65 GB.
#                1.49f 08/03/98 added separate 9.x kernel function
#                                 including many more kernel metrics
#                               moved kernel size to system section
#                               rewrote header section for HTML
#                               added batch print for software section
#                               changed lanscan -i for 9.x
#                1.49g 08/05/98 lots
#                1.50 08/06/98 fixed kernel parms on 10.x & 11.x
#                1.51 08/27/98 fixed savecore free space calculation when
#                                using non-standard lvol name
#                              added cstm extract of cpu & memory info
#                1.52 10/14/98 fixed adb on 11.0 with 64 bit kernel
#                              added display of 32 or 64 bit kernel on 11.0
#                1.53 10/16/98 added processor info from stm
#                              removed old SAM kernel code
#                1.54 10/20/98 increased field for PDC to 12 chars
#                1.55 10/20/98 fixed ifconfig problem with grep
#                1.56 10/20/98 added No such file or directory check to diskinfo
#                              changed rphysvol to use ioscan rather than
#                                      calculating
#                              increased display of hwpath for EMC drives
#                1.57 10/22/98 fixed bug in getting rdsk name
#                1.58 10/27/98 added bad block relocation to logical display
#                              added warning for EMC disks with LVM bad 
#                                     block relocation enabled
#                1.59 11/3/98  added check for iodevice w/o phyvol
#                                
#                1.70 04/12/99 added check for unsupported cstm versions
#                               < 09 & > 13
#                1.71 04/12/99 Numerous changes by Greg Sterling
#                              Code handles CRASHCONF utility
#                              Allows for dump devices in V11.x.
#                              Dump devices can be disk drives in addition
#                                  to logical volumes.
#                              Allow for Fibrechannel devices to be
#                                  accurately parsed in the Phys Device section.
#                              Updated the wait for ioscan to complete.
#                                  The prior time was 15 seconds, this is not
#                                  enough for a large system with many devices.
#                                  I increased the wait to 125 seconds.
#                              Fixed the "Last Patch" section to work with
#                                  a standard swinstall type system.
#                              Added security check. Checks file permissions
#                                  on some critical files and dirs, and checks
#                                  modem access.
#                              Check system log files (i.e.  syslog.log,
#                                  mail.log, btmp, and wtmp). These files are
#                                  known to get large very quickly.
#                              Changes the Date stamp on output files
#                                  to include a four digit year for Y2K reasons.
#                              Check the sendmail queue for old (older than
#                                  2 days) or large qty of entries.
#                              Added code to check/output information
#                                  related to system diags (if its installed).
#                                  This included diags and predictive.
#                                  This option only applies to V10.x and up.
#                              Fixed a few bugs in the code which limited
#                                  output to 10.10 or 10.20 systems. I had
#                                  to change some of the IF statements.
#                              For V10.x systems and higher I added the
#                                  /var/adm/sw/*.log files to the logfile
#                                  check routine.
#                1.72 04/25/99 fixed bug in crashconf size calculation
#                              added ip name to ip addr in networking
#                              moved 32/64 bit to follow OS version
#                              added check for non-configured software
#                                    i.e. transient, corrupt, available
#                                    or installed
#                              added listing of boot paths under bootable disks
#                1.73 05/14/99 fixed cstm hang problem - finally!
#                                 vers 12 reversed the meanings of the
#                                 SaveAs and Print commands for Infolog
#                1.74 05/25/99 improved formatting of cstm output
#                1.75 06/02/99 fixed bug when cstm_tot_phys = N/A
#                              added path to crashconf executable (/sbin/)
#                              fixed bug when Online dir has .2 suffix
#                1.76 07/12/99 several performance changes thanks to J. Semroc
#                              changed filesystem section 
#                                 added vxfs fragmentation; removed inodes
#                              added check if Vxfs version < 3 on > 10.10
#                              replaced cstm memory output
#                              added umask of 077 for security purposes
#                1.77 08/03/99 fixed Ignite version check for older versions
#                              removed cd-rom size from total p_size
#                1.78 09/07/99 added PA RISC chip and version
#                              removed cstm upper version check
#                1.78a 9/14/99 removed DVD size from total p_size
#                              increased sum lines for CAPACITY
#                              increased display size of product (model)
#                1.78b 9/18/99 Incorporated numerous changes by Jerry Schwartz:
#                                changed HTML output to use frames
#                                #fixed bug in physical disk enumeration
#                                fixed bug in check for /.profile
#                                made cosmetic changes to error messages
#                                   ("Logfile" changed to "Important file",
#                                   "doesn not" changed to "does not")
#                1.78c 10/2/99 Added cstm disk scan to retrieve firmware
#                                    and serial number info.
#                1.78d 10/11/99 Updated models table
#                1.78e
#                1.78f          Added XP256 information
#                1.79b
#                  |
#                1.79f 04/18/00 Added INSTALL script
#                               Added checks for diagmond to prevent hangs
#                               Added disk array checks for FC60, AutoRaid
#       	                   Cascade, and Nike.
#                1.79g 04/19/00 Added return to diagmond check
#                1.79h 05/15/00 Added additional system models
#                               Removed get_array_data due to cstm problem
#
#
# Acknowledgements:
# I would like to acknowledge the following for assistance in 
#               developing and testing this tool. 
#
# Jerry Schwartz, Jeff Semroc, Greg Sterling, Mike Ryan & Bill Taylor
# from the HP Account Support Organization for their help in debugging 
# and improving the code.
#
# LVMcollect.* scripts from Peter Van Giel in the Hewlett-Packard 
#        Country Response Center Belgium.
# capture script from Dave Olker of the Hewlett-Packard Worldwide 
#        Technology Expert Center.
#
# Most of all I would like to thank the PRODUNIX support team 
# at Oracle Corp. for allowing me access and time to develop 
# and test using their systems.
#
#
version="1.79h"                     #
umask 077
ROOT=$PWD                           #
export RESOLV_CONF=/etc/resolv.conf #
#script=`basename $0`               #
script="SysInfo"                    #
typeset PAGER=${PAGER:-more}        #
typeset -x osmajor                  #
typeset -R4 lcount=0                # number of logical volumes
typeset -R4 pcount=0                # number of physical volumes
typeset -R4 vgcount=0               # number of volume groups
typeset -i total_stale=0            # number of stales extents
typeset stale=0                     # flag set if stale extents found
typeset all_logvols                 # list of all logical volumes
typeset -L17 physvol                # name of phyical volume
typeset -R21 rphysvold              # name of raw phyical volume
typeset -R24 hwpathd                # path information for disk
typeset -L8 vendor                  # vendor id string from disk
typeset EMC_found=0                 # flag for EMC disks
typeset -R14 product                # vendor model number from disk
typeset -R1 bootable_pv             # is disk bootable?
typeset -R5 rev_level               # firmware revision code from disk
#typeset -R12 kernel_size           #\
typeset -i shmem                    # \
typeset -R8 shmmni                  #  \
typeset -R8 shmmax                  #   \
typeset -R8 shmseg                  #   \
typeset -R8 maxfiles                #    \
typeset -R8 maxfiles_lim            #     \
typeset -R8 maxuprc                 #      \
typeset -R8 nproc                   #       \ 
typeset -R8 fs_async                #        \ 
typeset -R8 nfile                   #           kernel parameters
typeset -R8 nflocks                 #          
typeset -R8 super_page_support      #        /
typeset -R8 dbc_max_pct             #       /
typeset -R8 dbc_min_pct             #      /
typeset -R8 ninode                  #     /  
typeset -R8 npty                    #    /
typeset -R8 nbuf                    #   /
typeset -R8 bufpages                #  /
typeset -R8 maxvgs                  # /
typeset SAVECORE                    # flag set if savecore is enabled
typeset COMPRESS=0                  #
typeset COMPRESSION="N/A"           # set if on 10.10 or later
typeset Compress_Option="N/A"       # enabled in /etc/rc.config.d/savecore
typeset -R8 lv_pbuf_cnt             # \
typeset -R8 lv_pbuf_inuse           #  \
typeset -R8 lv_pbuf_maxuse          #     more kernel parameters
typeset -R8 lv_pbuf_pending_Q       #     for lvm
typeset -R8 lv_vgs_opn              #  /
typeset -R8 lv_lvs_opn              # /
typeset -i psize                    # physical disk size (in KBytes)
typeset -R8 psize_mb                # physical disk size (in Mbytes)
### Changed 6/15/99 J.Semroc - Changed to handle large systems with 1000+ LU's
### typeset -R3 lu                      # physical disk logical unit number
typeset -R4 lu                      # physical disk logical unit number
### end of Change
typeset -L20 volgroup               #
typeset -R6  CURLV                  #
typeset -R10 CURPV                  #
typeset -R8  PeSize                 #
typeset -R9  AllocPe                #
typeset -R8  FreePe                 #
typeset -R8  TotalPe                #
typeset -R11 AllocMb                #
typeset -R8  FreeMb                 #
typeset -R8  TotalMb                #
typeset -R8 TotalAllocMb=0          # total allocated Megabytes
typeset -R8 TotalFreeMb=0           # total free Megabytes
typeset -R8 SystemTotalMb=0         # total of all Megabytes
typeset -R8 MirrorMb=0              # size of mirror
typeset -R8 TotalMirrorMb=0         # total size of mirrors
typeset -R8 OtherMb=0               #
typeset -R11 total_p_mb=0           # total physical Megabytes
typeset -R8 total_l_mb=0            # total logical Megabytes
typeset -R8 unused_cap=0            #
typeset -L4 fs_type                 #
typeset -R4 vxfs_frag               #
typeset -i no_lost=0                # flag if lost+found/.fsadm not found
typeset  logvol                     #
typeset -L40 logvold                #
typeset  pvol                       #
typeset -L16 statusout              # status of extents (e.g. stale)
typeset -R6 LVSize                  # size of logical volume
typeset -R7 LogicalExtents          #
typeset -R8 StaleExtents            #
typeset -L35 MOUNT                  #
typeset -R8 MirrorCopies            # number of mirrors
typeset -R8 Consistency             # mirror consistency strategy
typeset -i REAL_MEM                 # memory size (in pages)
typeset -i memory                   # memory size (in MBytes)
typeset -i num_cpus                 # number of active CPUs
typeset -i StaleMB=0                # stale Megabytes
typeset -i TotalStaleMb=0           # total stale Megabytes
typeset -i cpu_speed=0              # clock speed in MHz
typeset exit_code=0                 # exit code [ 0, 1, 2, 3 ]
typeset ERROR=1                     # exit condition (program error)
typeset WARN=2                      # exit condition (system warning)
typeset SYS_ERROR=3                 # exit condition (system error)
typeset SYSTEM=0                    # \
typeset FULL_KERNEL=0               #  \
typeset LITE_KERNEL=0               #   \
typeset FILESYSTEM=0                #    \
typeset NETWORK=0                   #     \
typeset DEBUG=0                     #      \
typeset SWLIST=0                    #       \
typeset PHYSICAL=0                  #         flags set at runtime via
typeset LOGICAL=0                   #         command line options
typeset IOSCAN=0                    #       /
typeset -x HTML=0                   #      /
typeset NOPAGER=0                   #     /
typeset VOLUMES=0                   #    /
typeset CAPACITY=0                  #   /
typeset BATCH=0                     #  /
typeset LMAP=0                      # /
typeset PMAP=0                      #/
typeset KernelSafetyFactor=2        # adds two MBytes to kernel size
typeset lvm_installed=0             # flag set if lvm present
typeset -R6 DumpDiskCapacity=0      # space to hold memory dump
typeset -R6 CompressedMemoryDumpSize #
typeset -R6 compression_factor      #
typeset -i MemoryDumpSize           # amount of memory (in MBytes)
typeset -i TotalMemoryDumpSize      # amount of memory + kernel size
typeset -R6 MemoryDumpSizeOut       # display version of MemoryDumpSize
typeset -R6 TotalMemoryDumpSizeOut  # display version of TotalMemoryDumpSize
typeset -R6 SaveCoreAvail_Out       # space to hold savecore
                                    # can be compressed on 10.10 and later
##############
# Variables for Chk_Logfiles section
##############
LOGFILELISTV10="/var/adm/syslog/syslog.log /var/adm/syslog/mail.log \
 /var/adm/btmp /var/adm/wtmp /var/adm/sw/swagent.log /var/adm/sw/swagentd.log \
 /var/adm/sw/swconfig.log /var/adm/sw/swcopy.log /var/adm/sw/swinstall.log \
 /var/adm/sw/swmodify.log /var/adm/sw/swreg.log /var/adm/sw/swremove.log"

LOGFILELISTV9="/usr/adm/syslog /usr/spool/mqueue/log /etc/btmp /etc/wtmp"
##############
# Variables for Chk_SysAccess section
##############
WORLDREADFILES="/etc/passwd /etc/group /etc/hosts /etc/services \
 /etc/inetd.conf"

NOREADFILES=~root/.profile
##############
# variables for io_scan section
##############
GREP_ARGS=""
GREP_V_ARGS="-eNO_HW"
typeset -x ioscan_args="-F"
typeset -x io_scan_out=/tmp/sysinfo.$$.io_scan.out
typeset -x io_scan_tmp=/tmp/sysinfo.$$.io_scan.tmp
typeset -x io_scan_done=/tmp/sysinfo.$$.io_scan_done
typeset -x io_scan_command_file=/tmp/sysinfo.$$.io_scan_command_file
##############
# variables for lvm_scan section
##############
typeset -x vg_list_file=/tmp/sysinfo.$$.vg.list
typeset -x vg_out_file=/tmp/sysinfo.$$.vg.out
typeset -x lvol_list_file=/tmp/sysinfo.$$.lvol.list
typeset -x lvol_out_file=/tmp/sysinfo.$$.lvol.out
typeset -x pvol_list_file=/tmp/sysinfo.$$.pvol.list
typeset -x pvol_out_file=/tmp/sysinfo.$$.pvol.out
typeset -x lvm_scan_command_file=/tmp/sysinfo.$$.lvm_scan_command_file
typeset -x lvm_scan_done=/tmp/sysinfo.$$.lvm_scan_done
##############
# variables for sam_scan section
##############
typeset -x sam_scan_command_file=/tmp/sysinfo.$$.sam_scan_command_file
typeset -x sam_scan_done=/tmp/sysinfo.$$.sam_scan_done
typeset -x sam_out_file=/tmp/sysinfo.$$.sam.out
#typeset -x sam_kinfo=/tmp/sysinfo.$$.kinfo
typeset -x sam_kinfo_new=/tmp/sysinfo.$$.kinfo_new
##############
# variables for kernel section
##############
typeset -x sam_kinfo=${sam_kinfo:-/tmp/sysinfo.$$.sam_kinfo}
typeset -x all_parms_file=/tmp/sysinfo.$$.all_parms
typeset -x all_classes_file=/tmp/sysinfo.$$.all_classes
##############
# variables for cstm section
##############
typeset -x cstm_command_file=/tmp/sysinfo.$$.cstm_command_file
typeset -x cstm_cpu_out=/tmp/sysinfo.$$.cstm_cpu_out
typeset -x cstm_cpu_out2=/tmp/sysinfo.$$.cstm_cpu_out2
typeset -x cstm_mem_out=/tmp/sysinfo.$$.cstm_mem_out
typeset -x cstm_disk_out=/tmp/sysinfo.$$.cstm_disk_out
typeset -x cstm_array_out=/tmp/sysinfo.$$.cstm_array_out
#############
# variables for sap section
#############
# translate uppercase to lowercase
TRUL='tr "ABCDEFGHIJKLMNOPQRSTUVWXYZ" "abcdefghijklmnopqrstuvwxyz"'
typeset -x r3_dir=/var/opt/perf/datafiles/r3dsi
typeset -x r3_prog=${r3_dir}/r3agent
typeset -i num_instances=0


ALL="TRUE"
FORCE="FALSE"
TEMPFILE=/var/sam/sam.$$
save_lang=$LANG
LANG=C


################################################################################
# Function:    DebugOn()
# Description: Turns debugging mode on.
# Arguments:   none
# Returns:     none

DebugOn() {
#   set -o xtrace
    export _DEBUG=1
    export _DEBUG_FILE=/tmp/sysinfo_${sysname}_`date '+%Y%m%d'`_debug
    #Debug Debug ON: info will be logged to screen and to $_DEBUG_FILE
    print "\nDebug ON: info will be logged to $_DEBUG_FILE"
    Debug  Debug ON: info will be logged to $_DEBUG_FILE
}

################################################################################
# Function:    DebugOff()
# Description: Turns debugging mode off.
# Arguments:   none
# Returns:     none

DebugOff() {

    Debug Debug OFF
    _DEBUG=0
    _DEBUG_FILE=$ROOT/debug.out
}

###############################################################################
# Function:    Debug()
# Description: Prints debug statements to stderr when debug mode is on.
# Arguments:   Text to echo.
# Returns:     none

Debug() {

    if [ "$_DEBUG" -gt 0 ]
    then
        #echo "DEBUG (PID $$): $*" | tee -a $_DEBUG_FILE 1>&2
        echo "DEBUG (PID $$): $*" >> $_DEBUG_FILE 2>&1
    fi
}


#-----------------------------------------------------------#
# Exit function, called by trapped signals
#-----------------------------------------------------------#
function _sigexit
{
# print "Cleaning up, please wait."
  if (($DEBUG)) && ((!(($NOPAGER)) ))
  then
    read answer?"Delete temp files? [Y/n]"
    if [[ ${answer} = n ]]
    then
      print "O.K.  Don't forget to delete /tmp/sysinfo.$$.*"
      print "exit value = ${exit_code}" 
    else
      print "O.K.  I'm deleting temp files /tmp/sysinfo.$$.*"
      rm -f /tmp/sysinfo.$$.* > /dev/null 2>&1
      print "exit_code = ${exit_code}" 
    fi
  else
    rm -f /tmp/sysinfo.$$.* > /dev/null 2>&1
  fi
  exit ${exit_code}
}
trap _sigexit  EXIT KILL HUP QUIT INT


function usage
{
cat << EOF | $PAGER

${script} ${version} by Scott Truesdale

Usage:  ${script} [-aADfikKlLmMnpsSv] [-b|-H|-N]
        ${script} [-h]

       -a displays all of the following options.
       -A displays file access security.
       -D checks system diagnostic information.
       -f checks filesystems for free space.
       -h displays detailed help message.
       -i displays io configuration.
       -k displays brief kernel parameters.
       -K displays verbose kernel parameters.
       -l displays logical volume data.
       -L displays system logfile info.
       -m displays logical to physical disk mapping.
       -M displays physical to logical disk mapping.
       -n displays network interface data.
       -p displays physical disk data.
       -P checks for R/3 instances.
       -s displays the system and root disk data.
       -S displays software listing (swlist).
       -v displays volume group data.

       -b send output to a logfile.
       -H send output to a logfile in HTML format.
       -N turn off paging in screen mode.

Note: disk capacity data is displayed only when using -a or -lpv.

EOF
}                # end of usage

function print_help
{
export MANPATH=/usr/contrib/man:${where}:$MANPATH
# to debug help -d must come before -h
Debug "print_help"
Debug "  where=${where}"
Debug "  MANPATH=${MANPATH}"
if [[ -f ${where}/man1m/sysinfo.1m ]] || \
   [[ -f /usr/contrib/man/man1m/sysinfo.1m ]]
then
  man sysinfo
  exit_code=0
else
  print "Cannot find man page for ${script}!"
  print "Expected to find it in /usr/contrib/man/man1m/"
  exit_code=${ERROR}
fi
}


#===================================================================
# get_args
#      gets command line arguments passed in at run time
#===================================================================
function get_args
{
if (($# == 0))
then
#print "\n$Must specify one or more of the following:$\n"
 usage
 exit ${ERROR}
fi
while getopts :abdfhiklmnpsvADHKLMNPS arguments
do
  case $arguments in
    a) LITE_KERNEL=1
       LOGFILES=1
       FILEACCESS=1
       DIAGNOSTICS=1  
       SYSTEM=1
       NETWORK=1
       IOSCAN=1
       LVMSCAN=1
       PHYSICAL=1
       VOLUMES=1
       LOGICAL=1
       FILESYSTEM=1
       SWLIST=1
       PMAP=1
       LMAP=1;;
    A) FILEACCESS=1;;
    b) BATCH=1 

         LOGDIR=${SYSINFO_LOGDIR:-"/tmp"}
         LOGFILE="${LOGDIR}/sysinfo_${sysname}_`date '+%Y%m%d'`"
         Debug "Removing $LOGFILE"
         rm -f $LOGFILE > /dev/null 2>&1

       ;;
    d) DEBUG=1
         DebugOn;;
    D) DIAGNOSTICS=1;;
    f) FILESYSTEM=1;;
    h) print_help
         exit ${exit_code};;
    H) HTML=1
       BATCH=1
       LOGFILES=1
       LITE_KERNEL=1
       FILEACCESS=1
       DIAGNOSTICS=1  
       SYSTEM=1
       NETWORK=1
       PHYSICAL=1
       VOLUMES=1
       IOSCAN=1
       LVMSCAN=1
       LOGICAL=1
       FILESYSTEM=1
       SWLIST=1
       PMAP=1
       LMAP=1
       LOGDIR=${SYSINFO_LOGDIR:-"/tmp"}
       LOGFILE="${LOGDIR}/sysinfo_${sysname}_`date '+%Y%m%d'`.html"
       if [[ -f ${LOGFILE} ]]
       then
         rm -f $LOGFILE >> /dev/null 2>&1
         Debug "Removing $LOGFILE"
       fi
       LOGFILE_INDEX_REL="`basename ${LOGFILE} .html`.index.html"
       LOGFILE_INDEX="`dirname ${LOGFILE}`/${LOGFILE_INDEX_REL}"
       if [[ -f ${LOGFILE_INDEX} ]]
       then
         rm -f ${LOGFILE_INDEX} >> /dev/null 2>&1
         Debug "Removing ${LOGFILE_INDEX}"
       fi
       LOGFILE_MAIN_REL="`basename ${LOGFILE} .html`.main.html"
       LOGFILE_MAIN="`dirname ${LOGFILE}`/${LOGFILE_MAIN_REL}"
       if [[ -f ${LOGFILE_MAIN} ]]
       then
         rm -f ${LOGFILE_MAIN} >> /dev/null 2>&1
         Debug "Removing ${LOGFILE_MAIN}"
       fi;;
    i) IOSCAN=1;;
    k) LITE_KERNEL=1;;
    K) FULL_KERNEL=1;;
    l) LOGICAL=1 
       LVMSCAN=1;;
    L) LOGFILES=1;;
    m) LMAP=1;;
    M) PHYSICAL=1
       SYSTEM=1
       PMAP=1;;
    n) NETWORK=1;;
    p) PHYSICAL=1
       SYSTEM=1;;
    P) PASS=1;;
    s) SYSTEM=1;;
    S) SWLIST=1;;
    v) VOLUMES=1
       LVMSCAN=1;;
    N) NOPAGER=1;;
    ?) print "\nI don't understand that option\n" 
       usage
       exit ${ERROR};;
  esac
  if (($PHYSICAL)) && (($VOLUMES)) && (($LOGICAL))
  then
    CAPACITY=1
  fi
  if (($LITE_KERNEL)) && (($FULL_KERNEL))
  then
    LITE_KERNEL=0
  fi
  if (($BATCH)) && (($DEBUG))
  then
    NOPAGER=1
  fi
done
Debug "FLAGS: System=$SYSTEM Batch=$BATCH FullKernel=$FULL_KERNEL"
Debug "FLAGS: LiteKernel=$LITE_KERNEL Network=$NETWORK"
Debug "FLAGS: Volumes=$VOLUMES Capacity=$CAPACITY Logical=$LOGICAL"
Debug "FLAGS: Physical=$PHYSICAL LMapping=$LMAP PMapping=$PMAP"
Debug "FLAGS: Filesystem=$FILESYSTEM NoPager=$NOPAGER Html=$HTML"
Debug "FLAGS: Ioscan=$IOSCAN lvm_scan=$LVMSCAN Sam_scan=$SAMSCAN"
Debug "FLAGS: Swlist=$SWLIST Diagnostics=$DIAGNOSTICS"
Debug "FLAGS: PASS=$PASS"
if (($BATCH))
then
  print "\nOutput going to ${LOGFILE}"
fi
}                # end of get_args


#===================================================================
# f_display_file
#      this function displays a file to the screen. it takes one parm, 
#      the file to display. It uses the defined PAGER or more if that
#      variable is not defined.
#===================================================================
function f_display_file
{
  if [[ -s $1 ]]
  then
    if (($BATCH))
    then
      cat $1 >> $LOGFILE
      if (($HTML))
      then
        grep -v "#Top" $1 | grep -v "TOP</A" >> $LOGFILE_MAIN
      fi
    elif (($NOPAGER))
    then
      cat $1
    else                        # not batch so use PAGER
      $PAGER $1
    fi
  fi
}                # end of f_display_file


###############################################################################
# Function:    check_for_sap
# Description: Check for any instances of R/3 by running r3agent -all.
#              The output is scanned for the required info.
#
# The r3agentSYSTEM output is as follows:
#  01 "31G" "QAS" "sapgui sapd370 nr=01 name=QAS"
#
# The r3agentCONFIGURATION output is as follows:
#  01 "DVEBMGS01" "QAS" "sapd370" ""

function check_for_sap
{
  print "Checking for SAP R/3 instances."
  DB_on_this_sys=0
  if (($HTML))
  then
    print "</PRE>"                  >> /tmp/sysinfo.$$.sap
    print "<A name='SAP'></A>"      >> /tmp/sysinfo.$$.sap
    print "<H2>"                    >> /tmp/sysinfo.$$.sap
    print "<P ALIGN=RIGHT><A HREF='#Top'>" >> /tmp/sysinfo.$$.sap
    print "TOP</A></P>"                    >> /tmp/sysinfo.$$.sap
    print "<FONT COLOR=red>" >> /tmp/sysinfo.$$.sap
    print "SAP R/3 Info</FONT></H2>"  >> /tmp/sysinfo.$$.sap
    print "<PRE><font size = '4'>"  >> /tmp/sysinfo.$$.sap
  else
    print "" >> /tmp/sysinfo.$$.sap
    print "SAP R/3 Information" >> /tmp/sysinfo.$$.sap
    print "===================" >> /tmp/sysinfo.$$.sap
    print "" >> /tmp/sysinfo.$$.sap
  fi
  if [ -f ${r3_prog} ]
  then
    ${r3_prog} -all
    num_instances=$( cat ./r3agentSYSTEM | wc -l)
    if ((num_instances == 0))
    then
      print "No R/3 instances found."
      print "No R/3 instances found." >> /tmp/sysinfo.$$.sap
      rm ./r3agent[A-Z]* > /dev/null 2>&1
      break
    else
      print "Found ${num_instances} instances."
      cat ./r3agentCONFIGURATION | 
      while read inst_id INSTANCE_NAME SAPSYSTEMNAME SAPDBHOST p5 p6 p7
      do
        INSTANCE_NAME=$(echo ${INSTANCE_NAME} | sed -e 's/\"*//g')
        SID=$(echo ${SAPSYSTEMNAME} | sed -e 's/\"*//g')
        SAPDBHOST=$(echo ${SAPDBHOST} | sed -e 's/\"*//g')
        SAP_ADM="`echo $SID | $TRUL`adm"
        startsap=$(su - ${SAP_ADM}  -c  "alias startsap" 2>&1 | tail -1)
        sapstart=$(ps -ef | grep sapstart | grep -v grep | awk '{print $9}')
        #PROFILE_DIR=$(grep "^PROFILE_DIR" ${startsap} | awk -F\" '{print $2}')
        PROFILE_DIR=/usr/sap/${SID}/SYS/profile
        EXE_DIR=/usr/sap/${SID}/SYS/exe/run
        startprofile=$(grep "^START_PROFILE" ${startsap} |awk -F\" '{print $2}')
        #SAPDBHOST=$(awk -F= '/SAPDBHOST/ {print $2}' $PROFILE_DIR/DEFAULT.PFL)
        ${EXE_DIR}/disp+work -V > /tmp/sysinfo.$$.dispwork 2>&1

        Debug "Saving dispwork -V output file"
        cp /tmp/sysinfo.$$.dispwork ${r3_dir}/dispwork > /dev/null 2>&1

        r3kernel=$(grep "kernel release" /tmp/sysinfo.$$.dispwork | \
                    awk '{print $3}')
        r3patch=$(grep "patch level" /tmp/sysinfo.$$.dispwork | \
                    head -1 | awk '{print $3}')
        r3db=$(grep "database kernel" /tmp/sysinfo.$$.dispwork | \
                    awk '{print $4}')
        r3dbver=$(grep "database kernel" /tmp/sysinfo.$$.dispwork | \
                    awk '{print $5}')
        if [[ -f ${PROFILE_DIR}/${startprofile} ]]
        then
          Debug "Saving profile ${PROFILE_DIR}/${startprofile}"
          cp ${PROFILE_DIR}/${startprofile} ${r3_dir} > /dev/null 2>&1
        fi
        if [[ $SAPDBHOST = $sysname ]]
        then
          DB_on_this_sys=1
          startdb=${EXE_DIR}/startsb
          ORASID="ora`echo $SID | $TRUL`"
          ORACLE_HOME=/oracle/${SID}
          db_profile=${ORACLE_HOME}/dbs/init${SID}.ora
          INITORA=$ORACLE_HOME/dbs/init${SID}.ora
          if [[ -f ${db_profile} ]]
          then
            Debug "Saving profile ${db_profile}"
            cp ${db_profile} ${r3_dir} > /dev/null 2>&1
          fi
        fi
        print "  Instance ID     = $inst_id"         >> /tmp/sysinfo.$$.sap
        print "  Instance Name   = ${INSTANCE_NAME}" >> /tmp/sysinfo.$$.sap
        print "  SAP System Name = ${SID}"           >> /tmp/sysinfo.$$.sap
        print "  R/3 Kernel Vers = ${r3kernel}"      >> /tmp/sysinfo.$$.sap
        print "  R/3 Patch Level = ${r3patch}"       >> /tmp/sysinfo.$$.sap
        print "  R/3 DB Vendor   = ${r3db}"          >> /tmp/sysinfo.$$.sap
        print "  R/3 DB Version  = ${r3dbver}"       >> /tmp/sysinfo.$$.sap
        print "  SAP adm user    = ${SAP_ADM}"       >> /tmp/sysinfo.$$.sap
        print "  startsap        = ${startsap}"      >> /tmp/sysinfo.$$.sap
        print "  sapstart        = ${sapstart}"      >> /tmp/sysinfo.$$.sap
        print "  Profile Dir     = ${PROFILE_DIR}"   >> /tmp/sysinfo.$$.sap
        print "  startprofile    = ${startprofile}"  >> /tmp/sysinfo.$$.sap
        print "  SAPDBHOST       = ${SAPDBHOST}"     >> /tmp/sysinfo.$$.sap
        if (($DB_on_this_sys))
        then
          print "  DB_on_this_sys  = true"           >> /tmp/sysinfo.$$.sap
          print "    ORASID        = ${ORASID}"      >> /tmp/sysinfo.$$.sap
          print "    ORACLE_HOME   = ${ORACLE_HOME}" >> /tmp/sysinfo.$$.sap
          print "    INITORA       = ${INITORA}"     >> /tmp/sysinfo.$$.sap
        else
          print "  DB_on_this_sys  = false"          >> /tmp/sysinfo.$$.sap
        fi
        print "" >> /tmp/sysinfo.$$.sap
      done
    fi
  else
    print "  r3agent not found!"
    print "  Scanning for dw.sap processes."
    allinst=$(ps -ef | grep dw.sap | grep -v grep | awk '{print $(NF -1)}' | sort | uniq)
    if [[ -z $allinst ]]
    then
      num_instances=0
    else
      num_instances=$(echo $allinst | wc -w)
    fi
    if ((num_instances == 0))
    then
      print "No R/3 instances found."
      print "No R/3 instances found." >> /tmp/sysinfo.$$.sap
      break
    else
      print "Found ${num_instances} instances."
      for inst in ${allinst}
      do
        numchar=$(echo $inst | wc -c)
        (( numchar = numchar - 1 ))
        (( numchar1 = numchar - 1 ))
        SID=$(echo $inst | cut -b7-9)
        inst_id=$(echo $inst | cut -b${numchar1}-${numchar})
        INSTANCE_NAME=$(echo $inst | cut -b11-${numchar})
        SAP_ADM="`echo $SID | $TRUL`adm"
        PROFILE_DIR=/usr/sap/${SID}/SYS/profile
        startsap=$(su - ${SAP_ADM}  -c  "alias startsap" 2>&1 | tail -1)
        #sapstart=$(ps -ef | grep sapstart | grep $SID |grep -v grep | awk '{print $9}')
        sapstart=$(ls -L ${PROFILE_DIR}/START_${INSTANCE_NAME})
        #echo $sapstart
        startprofile=$(grep "^START_PROFILE" ${sapstart} |awk -F\" '{print $2}')
        EXE_DIR=/usr/sap/${SID}/SYS/exe/run
        SAPDBHOST=$(awk -F= '/SAPDBHOST/ {print $2}' $PROFILE_DIR/DEFAULT.PFL)
        SAPDBHOST=$(echo $SAPDBHOST | sed -e 's/\ *//g')
        if [[ $SAPDBHOST = $sysname ]]
        then
          DB_on_this_sys=1
          startdb=${EXE_DIR}/startsb
          ORASID="ora`echo $SID | $TRUL`"
          ORACLE_HOME=/oracle/${SID}
          INITORA=$ORACLE_HOME/dbs/init${SID}.ora
          if [[ -f ${db_profile} ]]
          then
            Debug "Saving profile ${db_profile}"
            cp ${db_profile} ${r3_dir} > /dev/null 2>&1
          fi
        fi
        ${EXE_DIR}/disp+work -V > /tmp/sysinfo.$$.dispwork 2>&1

        Debug "Saving dispwork -V output file"
        cp /tmp/sysinfo.$$.dispwork ${r3_dir}/dispwork > /dev/null 2>&1

        r3kernel=$(grep "kernel release" /tmp/sysinfo.$$.dispwork | \
                    awk '{print $3}')
        r3patch=$(grep "patch level" /tmp/sysinfo.$$.dispwork | \
                    head -1 | awk '{print $3}')
        r3db=$(grep "database kernel" /tmp/sysinfo.$$.dispwork | \
                    awk '{print $4}')
        r3dbver=$(grep "database kernel" /tmp/sysinfo.$$.dispwork | \
                    awk '{print $5}')

        print "  Instance ID     = $inst_id"         >> /tmp/sysinfo.$$.sap
        print "  Instance Name   = ${INSTANCE_NAME}" >> /tmp/sysinfo.$$.sap
        print "  SAP System Name = ${SID}" >> /tmp/sysinfo.$$.sap
        print "  R/3 Kernel Vers = ${r3kernel}"      >> /tmp/sysinfo.$$.sap
        print "  R/3 Patch Level = ${r3patch}"       >> /tmp/sysinfo.$$.sap
        print "  R/3 DB Vendor   = ${r3db}"          >> /tmp/sysinfo.$$.sap
        print "  R/3 DB Version  = ${r3dbver}"       >> /tmp/sysinfo.$$.sap
        print "  SAP adm user    = ${SAP_ADM}"       >> /tmp/sysinfo.$$.sap
        print "  startsap        = ${startsap}"      >> /tmp/sysinfo.$$.sap
        print "  sapstart        = ${sapstart}"      >> /tmp/sysinfo.$$.sap
        print "  Profile Dir     = ${PROFILE_DIR}"   >> /tmp/sysinfo.$$.sap
        print "  startprofile    = ${startprofile}"  >> /tmp/sysinfo.$$.sap
        print "  SAPDBHOST       = ${SAPDBHOST}"     >> /tmp/sysinfo.$$.sap
        if (($DB_on_this_sys))
        then
          print "  DB_on_this_sys  = true" >> /tmp/sysinfo.$$.sap
          print "    ORASID        = ${ORASID}" >> /tmp/sysinfo.$$.sap
          print "    ORACLE_HOME   = ${ORACLE_HOME}" >> /tmp/sysinfo.$$.sap
          print "    INITORA       = ${INITORA}" >> /tmp/sysinfo.$$.sap
        else
          print "  DB_on_this_sys  = false" >> /tmp/sysinfo.$$.sap
        fi
        print "" >> /tmp/sysinfo.$$.sap
      done
    fi
  fi

}

###############################################################################
# Function:    chk_ignite()
# Description: Check if IgniteUX is installed. If so, check for the last
#              completed make_recovery. Check if make_recovery -C has been
#              run. If so, run check_recovery and display results.
#
# Arguments:   none
# Returns:     none

function chk_ignite
{
  Debug "  Starting chk_ignite"
  if [[ ${osmajor} <  10 ]]
  then
    print "IgniteUX is not supported on less that HP-UX 10.x"
    Debug "  Unsupported HP-UX version $osmajor"
    break
  fi
  print "Checking for IgniteUX."
  if [ -d /opt/ignite ]
  then
    if [ -f /opt/ignite/Version ]
    then
      ignite_ver=$(cat /opt/ignite/Version)
      print "IgniteUX is installed. Version = $ignite_ver" >> \
                   /tmp/sysinfo.$$.ignite
    else
      print "IgniteUX is installed. Version = N/A." \
                >> /tmp/sysinfo.$$.ignite
    fi
    if [ -f /var/opt/ignite/logs/makerec.log1 ]
    then
      last_make_recovery=$(grep Completed /var/opt/ignite/logs/makerec.log1)
      if [ -z $last_make_recovery ]
      then
        print "WARNING (${sysname}): IGNITE make_recovery not run." >> \
                 /tmp/sysinfo.$$.errwarn
      else
        print "Most recent make_recovery  = ${last_make_recovery}" >> \
                 /tmp/sysinfo.$$.ignite
      fi
    else
      print "WARNING (${sysname}): IGNITE make_recovery not run or logfile deleted." \
              >> /tmp/sysinfo.$$.errwarn
    fi
    if [ -f /var/opt/ignite/recovery/makerec.last ]
    then
      check_recovery #> /dev/null 2>&1
    else
      print "WARNING (${sysname}): IGNITE check_recovery log not found"  \
              >> /tmp/sysinfo.$$.errwarn
    fi
  else
    print "WARNING (${sysname}): IgniteUX is NOT installed." \
            >> /tmp/sysinfo.$$.errwarn
  fi
  f_display_file /tmp/sysinfo.$$.ignite
}
###############################################################################
# Function:    chk_diags()
# Description: Check the system's diagnostic software configuration.  Output
#              the predictive setting if its installed. This is important info.
#
# Arguments:   none
# Returns:     none

chk_diags()
{
  Debug "  Starting Chk_Diags. OSMAJOR = $osmajor"

  if (($HTML))
  then
    print "</PRE>"  >> /tmp/sysinfo.$$.diagnostics.info
    print "<A NAME='DIAGNOSTICS'></A>"  >> \
               /tmp/sysinfo.$$.diagnostics.info
    print "<H2>" >> \
               /tmp/sysinfo.$$.diagnostics.info
    print "<P ALIGN=RIGHT><A HREF='#Top'>TOP</A></P>" >> \
               /tmp/sysinfo.$$.diagnostics.info
    print "<FONT COLOR=red>"                >> \
               /tmp/sysinfo.$$.diagnostics.info
    print "System Diagnostics Settings</H2>" >> \
               /tmp/sysinfo.$$.diagnostics.info
    print "</FONT><PRE><font size = '4'>"   >> \
               /tmp/sysinfo.$$.diagnostics.info
  else
    print "SYSTEM DIAGNOSTICS SETTINGS" >> \
               /tmp/sysinfo.$$.diagnostics.info
    print "==========================" >> \
               /tmp/sysinfo.$$.diagnostics.info
  fi

  print -n "checking system diagnostics "

  print "" >> /tmp/sysinfo.$$.diagnostics.info
  case $osmajor in
    10 | 11 )
#
# Look for the OnlineDiag product file. If it exists, then the product is
# installed on the system. You can use the product's INDEX file to get the
# product version (this can be important info).
#
      print ".\c"
      prodfile=$(ls -d /var/adm/sw/products/OnlineDiag* 2>&1)
      Debug "Found OnlineDiag dir - ${prodfile}"
      if [ -d "$prodfile" ]
      then
        print -n "Online Diagnostics are Installed: " \
                  >> /tmp/sysinfo.$$.diagnostics.info
        print "Version: $(grep ^revision $prodfile/pfiles/INDEX \
            | awk '{print $NF}')\t\c" >> /tmp/sysinfo.$$.diagnostics.info
        print "Status: \c" >> /tmp/sysinfo.$$.diagnostics.info
#
# Now use the PS command to see if diagnostics are running.
#
       ps -ef | grep -q diagmon
       if [ $? -eq 0 ]
       then
         print "Running" >> /tmp/sysinfo.$$.diagnostics.info
       else
         print "Down" >> /tmp/sysinfo.$$.diagnostics.info
       fi
       print "" >> /tmp/sysinfo.$$.diagnostics.info
#
# If the diagnostics software is properly installed then there should be
# programs in the LIF area named ODE, MAPPER, and MAPFILE. If these values
# are not present, then diags will not run from console mode.
#
# By checking all boot disks (obtained from lvlnboot -v), we also check
# any mirrored volumes. This is good because mirrored root volumes are
# often missed.
#
       typeset -i liferrors
       bootdsks=$(lvlnboot -v 2>/dev/null | grep "Boot Disk" | awk '{print $1}')

       print "Checking LIF Information (ODE, MAPPER and, MAPFILE)" >> \
              /tmp/sysinfo.$$.diagnostics.info
       print ".\c"
#
# Now loop for each boot disk found by lvlnboot -v. This will check mirrors
# as well as primary disks. All boot disks should have diags installed.
#
       for bdisk in $bootdsks
       do
         liferrors=0
         lifls -l $bdisk >> /tmp/sysinfo.$$.diagnostics.lifinfo
         for lfdiag in ODE MAPPER MAPFILE
         do
           grep -q $lfdiag /tmp/sysinfo.$$.diagnostics.lifinfo
           if [ $? -ne 0 ]
           then
             print "WARNING (${sysname}): Missing $lfdiag on ${bdisk}." \
                  >> /tmp/sysinfo.$$.errwarn
             liferrors=liferrors+1
           fi
         done
#
# If the liferrors variable is greater than zero then this disk was missing at
# least one of the required LIF files. If its equal to zero, then this disk
# has all the required info.
#
         if [ $liferrors -eq 0 ]
         then
           print "$bdisk\tOK" >> /tmp/sysinfo.$$.diagnostics.info
         fi
        done
      else
      print "WARNING (${sysname}): Online Diagnostics are NOT Installed." >> \
            /tmp/sysinfo.$$.errwarn
      print "Online Diagnostics are NOT Installed." >> \
            /tmp/sysinfo.$$.diagnostics.info
      fi
#
# Now check the system product database to see if Predictive is installed. 
# If it is, then output its version info, and check to see if its running 
# (again using the ps command).
#
      print ".\c"
      print " " >> /tmp/sysinfo.$$.diagnostics.info
      prodfile=$(ls -d /var/adm/sw/products/Predictive* 2>&1)
      Debug "Found Predictive dir - ${prodfile}"
      if [ -d "$prodfile" ]
      then
        print -n "Predictive is Installed: Version:" \
             >> /tmp/sysinfo.$$.diagnostics.info
        print " $(grep ^revision $prodfile/pfiles/INDEX | awk \
            '{print $NF}')\t\c" >> /tmp/sysinfo.$$.diagnostics.info
        print "Status: \c" >> /tmp/sysinfo.$$.diagnostics.info
        ps -ef | grep -q psmond
        if [ $? -eq 0 ]
        then
          print "Running" >> /tmp/sysinfo.$$.diagnostics.info
        else
          print "Down" >> /tmp/sysinfo.$$.diagnostics.info
        fi
#
# Predictive is installed. Run PSCONFIG to output the configuration info and
# the recent log history. This is good documentation of the system, and shows
# whether the system has been reporting problems to the response center.
#
        print ".\c"
        print "" >> /tmp/sysinfo.$$.diagnostics.info
        print "Predictive Configuration Information" >> \
                     /tmp/sysinfo.$$.diagnostics.info 
        if [ -x /opt/pred/bin/PSCONFIG ]
        then
          print ".\c"
          /opt/pred/bin/PSCONFIG print configuration >> \
                     /tmp/sysinfo.$$.diagnostics.info 2>/dev/null
          print ".\c"
          /opt/pred/bin/PSCONFIG print action >> \
                     /tmp/sysinfo.$$.diagnostics.info 2>/dev/null
        else
          print "ARNING (${sysname}): PSCONFIG is not executable" >> \
                        /tmp/sysinfo.$$.errwarn
        fi
      else
        print "Predictive is NOT Installed." >> \
                    /tmp/sysinfo.$$.diagnostics.info
        print "WARNING (${sysname}): Predictive is NOT Installed." >> \
                    /tmp/sysinfo.$$.errwarn
      fi
    ;;
#
# I did not implement any code which would work with V9.x or earlier. At this
# point, most customers should be at V10.x by now. V9.x is off support life.
#
    8 | 9 )
      print "This module was created for V10.x and higher. Sorry."
    ;;
  esac

  print ""
  print "" >> /tmp/sysinfo.$$.diagnostics.info

  f_display_file /tmp/sysinfo.$$.diagnostics.info

  return $return_code
}

###############################################################################
# Function:    chk_sysaccess()
# Description: Routine used to check some of the security characteristics of
#              the system. This includes checking the permissions of the
#              /etc/passwd, and /etc/group files as well as checking for
#              .rhosts and other files.
# Arguments:   none
# Returns:     none

chk_sysaccess() {
  Debug "  Starting Chk_SysAccess. OSMAJOR = $osmajor"

  if (($HTML))
  then
    print "</PRE>"  >> /tmp/sysinfo.$$.sysaccess.info
    print "<A NAME='SYSACCESS'></A>" >> /tmp/sysinfo.$$.sysaccess.info
    print "<H2>"    >> /tmp/sysinfo.$$.sysaccess.info
    print "<P ALIGN=RIGHT><A HREF='#Top'>" >> /tmp/sysinfo.$$.sysaccess.info
    print "TOP</A></P>" >> /tmp/sysinfo.$$.sysaccess.info
    print "<FONT COLOR=red>" >> /tmp/sysinfo.$$.sysaccess.info
    print "System Security Audit</H2>" >> /tmp/sysinfo.$$.sysaccess.info
    print "</FONT><PRE><font size = '4'>" >> /tmp/sysinfo.$$.sysaccess.info
  else
    print "SYSTEM SECURITY AUDIT" >> /tmp/sysinfo.$$.sysaccess.info
    print "==========================" >> /tmp/sysinfo.$$.sysaccess.info
  fi

  last -R > /tmp/sysinfo.$$.last 
  print -n "checking system security "
  print "" >> /tmp/sysinfo.$$.sysaccess.info

  print "File Permissions. Files which should be World and Group Read-Only." \
           >>  /tmp/sysinfo.$$.sysaccess.info

  for lfile in $WORLDREADFILES
  do
    Debug "   chk_SysAccess. Checking $lfile."
    if [[ ! -a "$lfile" ]]
    then
      print "ERROR ($sysname): Important file $lfile does not exist." >> \
              /tmp/sysinfo.$$.errwarn
      return_code=$ERROR
    else
#
# Get the important file's directory information.
#
      llinfo=$(ll -d $lfile)
#
# Now check the file's permissions
#
      echo "$llinfo" | cut -c5-10 | egrep -q "w"
      if [ $? -eq 0 ]
      then
        print "WARNING ($sysname): Important file $lfile has Group or World WRITE access.  " >> /tmp/sysinfo.$$.errwarn
        return_code=$WARN
      fi
    echo "$llinfo" >> /tmp/sysinfo.$$.sysaccess.info
    fi
  done
#
# Now check the system for files/directories which should be accessible to
# root only. This code will flag files which have any access other than the
# owner.
#
  print "" >> /tmp/sysinfo.$$.sysaccess.info
  print "File Permissions. Files which should be Accessible to Root only." >> \
             /tmp/sysinfo.$$.sysaccess.info

  for lfile in $NOREADFILES
  do
    Debug "   chk_SysAccess. Checking $lfile."
    if [[ ! -a "$lfile" ]]
    then
      print "WARNING ($sysname): Important file $lfile does not exist." >> \
               /tmp/sysinfo.$$.errwarn
      return_code=$WARN
    else
#
# Get the Important file's directory information.
#
      llinfo=$(ll -d $lfile)
#
# Now check the file's permissions
#
      echo "$llinfo" | cut -c5-10 | egrep -q "r|w|x"
      if [ $? -eq 0 ]
      then
        print "WARNING ($sysname): Important file $lfile has Group or World access." \
                >> /tmp/sysinfo.$$.errwarn
        return_code=$WARN
      fi
      echo "$llinfo" >> /tmp/sysinfo.$$.sysaccess.info
    fi
  done

  print "" >> /tmp/sysinfo.$$.sysaccess.info
  print "Check for Important Audit Files:" >> /tmp/sysinfo.$$.sysaccess.info
#
# Now check for the wtmp and btmp files. These are important to login history.
# make sure they exist, if not, then give a warning. then check their security.
# The wtmp file tracks login history. The btmp file tracks invalid logons.
#
# Also check the sulog file. This file tracks the history of SU'ing to root.
#
  case $osmajor in
    8 | 9 )
      WTMP="/etc/wtmp"
      BTMP="/etc/btmp"
      SULOG="/usr/adm/sulog"
    ;;

    * )
      WTMP="/var/adm/wtmp"
      BTMP="/var/adm/btmp"
      SULOG="/var/adm/sulog"
    ;;
  esac
#
# Check the wtmp file
#
  if [[ ! -a "$WTMP" ]]
  then
    print "WARNING ($sysname): Audit File $WTMP does not exist." >> \
                /tmp/sysinfo.$$.errwarn
    print "If you create $WTMP you can track logon history." >> \
                /tmp/sysinfo.$$.errwarn
    print " " >> /tmp/sysinfo.$$.errwarn
  else
    llinfo=$(ll -d $WTMP)

    echo "$llinfo" | cut -c8-10 | egrep -q "w"
    if [ $? -eq 0 ]
    then
      print -n "WARNING ($sysname): Audit File $WTMP has Group or " >> \
                  /tmp/sysinfo.$$.errwarn
      print "World WRITE access." >> /tmp/sysinfo.$$.errwarn
      print "   $WTMP should have at most World read access." >> \
                  /tmp/sysinfo.$$.errwarn
      print " " >> /tmp/sysinfo.$$.errwarn
    fi
    echo "$llinfo" >> /tmp/sysinfo.$$.sysaccess.info
  fi
#
# Now check the btmp file.
#
  if [[ ! -a "$BTMP" ]]
  then
    print "WARNING ($sysname): Audit File $BTMP does not exist." >> \
               /tmp/sysinfo.$$.errwarn
    print "If you create $BTMP you can track invalid logon history." >> \
               /tmp/sysinfo.$$.sysaccess.warn
    print " " >> /tmp/sysinfo.$$.sysaccess.warn
  else
    llinfo=$(ll -d $BTMP)

    echo "$llinfo" | cut -c5-10 | egrep -q "w"
    if [ $? -eq 0 ]
    then
      print -n "WARNING ($sysname): Audit File $BTMP has Group or ">> \
                  /tmp/sysinfo.$$.errwarn
      print "World WRITE access." >> /tmp/sysinfo.$$.errwarn
      print "$BTMP should have at most Group or World read access." >> \
                  /tmp/sysinfo.$$.errwarn
      print " " >> /tmp/sysinfo.$$.errwarn
    fi

    echo "$llinfo" >> /tmp/sysinfo.$$.sysaccess.info
  fi
#
# Check the sulog file now.
#
  if [[ ! -a "$SULOG" ]]
  then
    print "WARNING ($sysname): Audit File $SULOG does not exist." >> \
        /tmp/sysinfo.$$.errwarn
    print "If you create $SULOG you can track su logon history." >> \
         /tmp/sysinfo.$$.sysaccess.warn
    print " " >> /tmp/sysinfo.$$.sysaccess.warn
  else
    llinfo=$(ll -d $SULOG)

    echo "$llinfo" | cut -c5-10 | egrep -q "w"
    if [ $? -eq 0 ]
    then
      print -n "WARNING ($sysname): Audit File $SULOG has Group or " >> \
                   /tmp/sysinfo.$$.errwarn
      print "World WRITE access." >> /tmp/sysinfo.$$.sysaccess.warn
      print "$SULOG should have at most Group or World read access." >> \
                  /tmp/sysinfo.$$.sysaccess.warn
      print " " >> /tmp/sysinfo.$$.sysaccess.warn
    fi

    echo "$llinfo" >> /tmp/sysinfo.$$.sysaccess.info
    print " " >> /tmp/sysinfo.$$.sysaccess.info
    print "Five Most Recent SUlog entries:" >> /tmp/sysinfo.$$.sysaccess.info
    tail -5 $SULOG >> /tmp/sysinfo.$$.sysaccess.info
  fi
#
# Check the validity of the /etc/passwd and /etc/group files by running
# the pwck and grpck commands. This will help identify illegal password and
# group entries. Also, check the /etc/passwd file for entries missing
# passwords.
#
  if [[ -x "/etc/pwck" ]]
  then
    print " " >> /tmp/sysinfo.$$.sysaccess.info
    print "Running Passwd Check Script:" >> /tmp/sysinfo.$$.sysaccess.info
    /etc/pwck >> /tmp/sysinfo.$$.sysaccess.info 2>&1
  fi
#
# Check the password file for entries w/o a password.
#
  awk -F: -v sysname=$sysname ' $2 == "" { printf("\nERROR. (%s).  NULL Password found in /etc/passwd\nPassword Record = %s\n\n",sysname,$0)}' /etc/passwd >> \
             /tmp/sysinfo.$$.errwarn 2>&1

  if [[ -x "/etc/grpck" ]]
  then
    print " " >> /tmp/sysinfo.$$.sysaccess.info
    print "Running Group Check Script:" >> /tmp/sysinfo.$$.sysaccess.info
    /etc/grpck >> /tmp/sysinfo.$$.sysaccess.info 2>&1

  fi
#
# Now check for an .rhost file definition for root.
# If this file exists, then print a message since this is a potential security
# issue.
#
  if [[ -a "/.rhosts" ]]
  then
    print "WARNING ($sysname): Root has a /.rhosts file." >> \
               /tmp/sysinfo.$$.errwarn
    print "This file allows users from other systems to logon as root w/o a password." >> /tmp/sysinfo.$$.errwarn
    print " " >> /tmp/sysinfo.$$.errwarn

    llinfo=$(ll -d /.rhosts)

    echo "$llinfo" | cut -c5-10 | egrep -q "r|w|x"
    if [ $? -eq 0 ]
    then
      print "WARNING ($sysname): The /.rhosts file has Group or World access." \
             >> /tmp/sysinfo.$$.errwarn
      print "If this existence if this file is required then ONLY root should have access." >> /tmp/sysinfo.$$.errwarn
      print " " >> /tmp/sysinfo.$$.errwarn
    fi

    echo "$llinfo" >> /tmp/sysinfo.$$.sysaccess.warn
    print "" >> /tmp/sysinfo.$$.sysaccess.warn
    print "Contents of /.rhosts file:" >> /tmp/sysinfo.$$.sysaccess.warn
    cat /.rhosts >> /tmp/sysinfo.$$.sysaccess.warn
  fi
#
# Now check the system for modem definitions. This first pass will not include
# uucp items. I'm checking for ttyd* files in the /dev directory, then I'll
# campare any matches to the /etc/inittab file. This will allow me to
# look for getty processes.
#
  print " " >> /tmp/sysinfo.$$.sysaccess.info
  print "Dialin/Modem Definitions:" >> /tmp/sysinfo.$$.sysaccess.info
  print " " >> /tmp/sysinfo.$$.sysaccess.info

  MLIST=$(ls /dev/ttyd*  2>&1)

  Debug "  chk_SysAccess. MLIST = $MLIST"
  for modtty in $MLIST
  do
    modttyb=$(basename $modtty)
    Debug "  chk_SysAccess. Checking = $modtty"
#
# Check the /etc/inittab file for the terminal entry. Exclude lines which
# begin with a '#'. Include lines which contain 'getty'
#
    gettyinfo=$( grep -v '^#' /etc/inittab | grep 'getty' | grep -i $modttyb )
    gettystate=$( echo $gettyinfo | awk -F: '{print $3}' )

    Debug "  chk_SysAccess. Getty Info/State = $gettyinfo $gettystate"
    case $gettystate in
      respawn )
        Debug " chkSysAccess. Respawn in getty"
        ps -ef | grep getty | grep -q $modttyb
        if [ $? -eq 0 ]
        then
          Debug "Found Getty for $modttyb"
          print "Modem: $modttyb (waiting for a connection)" >> \
             /tmp/sysinfo.$$.sysaccess.info
        else
          Debug "No Getty Found for $modttyb"
          if ps -t $modttyb | tail +2 | wc -l
          then
            Debug "No Processes Found for $modttyb"
            print "Modem: $modttyb (getty missing?)" >> \
                    /tmp/sysinfo.$$.sysaccess.info
            print "WARNING ($sysname): $modttyb does not have a getty or a login process" >> /tmp/sysinfo.$$.errwarn
          else
            Debug "Modem in Use"
            print "Modem: $modttyb (currently in use)" >> \
                     /tmp/sysinfo.$$.sysaccess.info
          fi
        fi

        echo $gettyinfo | awk -F: '{printf("Inittab Info: %s\n",$4)}' >> \
              /tmp/sysinfo.$$.sysaccess.info
        print " " >> /tmp/sysinfo.$$.sysaccess.info
        print "Five most recent Logons for $modttyb" >> \
                 /tmp/sysinfo.$$.sysaccess.info
        #last -R > /tmp/sysinfo.$$.last
        grep -i $modttyb /tmp/sysinfo.$$.last | tail -5 >> /tmp/sysinfo.$$.sysaccess.info
        print " " >> /tmp/sysinfo.$$.sysaccess.info
      ;;

      off )
        print "Modem: $modttyb (disabled in /etc/inittab)" >> \
                    /tmp/sysinfo.$$.sysaccess.info
      ;;

      * )
      ;;
    esac
  done
  print " "

  print " " >> /tmp/sysinfo.$$.sysaccess.info

  f_display_file /tmp/sysinfo.$$.sysaccess.info
  f_display_file /tmp/sysinfo.$$.sysaccess.warn

  return $return_code
}


###############################################################################
# Function:    chk_logfiles()
# Description: Routine used to check the system logfiles. We want to make sure
#              that the logfiles exist, and are not greater than 2 Mbytes.
# Arguments:   none
# Returns:     none

chk_logfiles() {
  Debug "  Starting Chk_Logfiles. OSMAJOR = $osmajor"

  case $osmajor in
    8 | 9 )
      FLIST="$LOGFILELISTV9"
    ;;

    * )
      FLIST="$LOGFILELISTV10"
    ;;
  esac

  Debug " chk_logfiles. FLIST=$FLIST"
  if (($HTML))
  then
    print "</PRE>"  >> /tmp/sysinfo.$$.logfile.info
    print "<A NAME='LOGFILES'></A>" >> /tmp/sysinfo.$$.logfile.info
    print "<H2>"    >> /tmp/sysinfo.$$.logfile.info
    print "<P ALIGN=RIGHT><A HREF='#Top'>" >> /tmp/sysinfo.$$.logfile.info
    print "TOP</A></P>" >> /tmp/sysinfo.$$.logfile.info
    print "<FONT COLOR=red>" >> /tmp/sysinfo.$$.logfile.info
    print "System Logfile Information</H2>" >> /tmp/sysinfo.$$.logfile.info
    print "</FONT><PRE><font size = '4'>"  >> /tmp/sysinfo.$$.logfile.info
  else
    print "SYSTEM LOGFILE INFORMATION" >> /tmp/sysinfo.$$.logfile.info
    print "==========================" >> /tmp/sysinfo.$$.logfile.info
  fi
  print -n "checking system logfiles"
  print "" >> /tmp/sysinfo.$$.logfile.info
  print "Checking System Logfiles. Validating file sizes and Permissions." >> \
              /tmp/sysinfo.$$.logfile.info

  for lfile in $FLIST
  do
    Debug "   chk_logfiles. Checking $lfile."
    if [[ ! -a "$lfile" ]]
    then
      print "ERROR ($sysname): Logfile $lfile does not exist." >> \
         /tmp/sysinfo.$$.errwarn
      return_code=$ERROR
    else
#
# Get the logfile's directory information. Then check its size.
#
      llinfo=$(ll -d $lfile)

      psize=$( echo $llinfo | awk '{print $5}' )
      if (( $psize >= 2097152 ))
      then
        print "WARNING ($sysname): Logfile $lfile is greater than 2 Mbytes." \
          >> /tmp/sysinfo.$$.errwarn
        return_code=$WARN
      fi
#
# Now check the file's permissions
#
      echo "$llinfo" | cut -c5-10 | egrep -q "w"
      if [ $? -eq 0 ]
      then
        print "WARNING ($sysname): Logfile $lfile has Group or World WRITE access.  " >> /tmp/sysinfo.$$.errwarn
        return_code=$WARN
      fi
      echo "$llinfo" >> /tmp/sysinfo.$$.logfile.info
    fi
  done

  print " " >> /tmp/sysinfo.$$.logfile.info
#
# Now check the system's crash directory for crash files. If these files exist
# there could be space problems later.
#
  case $osmajor in
    10 | 11 )
      if [[ -a "/etc/rc.config.d/savecrash" ]]
      then
        . /etc/rc.config.d/savecrash
        if [ ! -z "$CRASHDIR" ]
        then
          LOGCRASH=$CRASHDIR
        else
          LOGCRASH="/var/adm/crash"
        fi
      else
        LOGCRASH="/var/adm/crash"
      fi

      CRASHFILES=$(ll $LOGCRASH | tail +2)
      if [ -z "$CRASHFILES" ]
      then
        print "There are NO Crash Dumps in $LOGCRASH." >> \
                   /tmp/sysinfo.$$.logfile.info
      else
        print " " >> /tmp/sysinfo.$$.logfile.warn
        print "WARNING ($sysname): There are files in the Crash Dump directory $LOGCRASH." >> /tmp/sysinfo.$$.errwarn
        echo "$CRASHFILES" >> /tmp/sysinfo.$$.errwarn
      fi
    ;;

  * )
    ;;
  esac
#
# Now output the contents of the DMESG command. This can provide useful
# info regarding recent events on the system.
#
  print " " >> /tmp/sysinfo.$$.logfile.info
  print "Ouput of System DMESG Info:" >> /tmp/sysinfo.$$.logfile.info
  print "___________________________" >> /tmp/sysinfo.$$.logfile.info

  dmesg >> /tmp/sysinfo.$$.logfile.info 2>&1

  print " " >> /tmp/sysinfo.$$.logfile.info
  print "End of DMESG Output" >> /tmp/sysinfo.$$.logfile.info
  print "___________________________" >> /tmp/sysinfo.$$.logfile.info
  print " " >> /tmp/sysinfo.$$.logfile.info
#
# Now check the Sendmail Queue for a large number of entries, or entries
# which are older than two days. Finding entries in the queue could represent
# a problem.
#
  print " " >> /tmp/sysinfo.$$.logfile.info
  print "Checking Sendmail Queue: \c" >> /tmp/sysinfo.$$.logfile.info
#
# Before changing to the Sendmail Queue directory, save our current directory
# value so we can change back to it when we're finished.
#
  OLDPWD=$(pwd)
  case $osmajor in
    8 | 9 )
      mailqdir=/usr/spool/mqueue
      mailpodir=/usr/mail
    ;;

    * )
      mailqdir=/var/spool/mqueue
      mailpodir=/var/mail
    ;;
  esac
#
# Go to the Sendmail Queue directory and scan it for entries. Iff some are
# found then check to see if any are older than 2 days.
#
  cd $mailqdir
  llinfo=$(ll 2>&1 | tail +2)

  if [[ -z "$llinfo" ]]
  then
    print "Sendmail Queue is Empty." >> /tmp/sysinfo.$$.logfile.info
  else
    print "Sendmail Queue has $(ls | wc -w | awk '{print $1}') entries." >> \
            /tmp/sysinfo.$$.logfile.info
    ll 2>&1 | tail +2 >> /tmp/sysinfo.$$.logfile.info
#
# Use the find command to list entries older than 2 days
#
    findinfo=$(find . -mtime +2 -exec ll -d {} \;)
    if [[ ! -z "$findinfo" ]]
    then
      print " " >> /tmp/sysinfo.$$.logfile.warn
      print "Sendmail Queue has Entries Older than 2 days." >> \
                /tmp/sysinfo.$$.logfile.warn
      find . -mtime +2 -exec ll -d {} \; >> /tmp/sysinfo.$$.logfile.warn
      print " " >> /tmp/sysinfo.$$.logfile.warn
    fi
  fi
#
# Now change to the Sendmail Post Office directory. This is the directory
# where mail is normally stored on the system. Check for entries which are
# large and very old.
#
  cd $mailpodir
  print " " >> /tmp/sysinfo.$$.logfile.info
  print "Checking the Mail Post Office Directory: \c" >> \
              /tmp/sysinfo.$$.logfile.info

  llinfo=$(ls 2>&1)
  if [[ -z "$llinfo" ]]
  then
    print "No Entries Found." >> /tmp/sysinfo.$$.logfile.info
  else
    print "Found $(echo $llinfo | wc -w) Entries." >> \
               /tmp/sysinfo.$$.logfile.info
    ll 2>&1 >> /tmp/sysinfo.$$.logfile.info
#
# Now that we have found entries in the directory, check to see if they are
# larger than 2 Mbytes.
#
    find . -size +4096 -exec ll -d {} \; > /tmp/sysinfo.$$.logfile.tmp 2>&1
    if [[ -s "/tmp/sysinfo.$$.logfile.tmp" ]]
    then
      print " " >> /tmp/sysinfo.$$.logfile.warn
      print "WARNING ($sysname): Post Office Directory has Files Larger than 2 Mbytes." >> /tmp/sysinfo.$$.errwarn
      cat /tmp/sysinfo.$$.logfile.tmp >> /tmp/sysinfo.$$.errwarn
      print " " >> /tmp/sysinfo.$$.errwarn
    fi
#
# Now check for entries which have not been access in 90 days. These files
# may be considered obsolete.
#
    find . -mtime +90 -exec ll -d {} \; > /tmp/sysinfo.$$.logfile.tmp 2>&1
    if [[ -s "/tmp/sysinfo.$$.logfile.tmp" ]]
    then
      print " " >> /tmp/sysinfo.$$.logfile.warn
      print "WARNING ($sysname): Post Office Directory has Files Older than 90 days." >> /tmp/sysinfo.$$.errwarn
      cat /tmp/sysinfo.$$.logfile.tmp >> /tmp/sysinfo.$$.errwarn
      print " " >> /tmp/sysinfo.$$.errwarn
    fi
  fi
#
# Change back to our original directory
#
  cd $OLDPWD

  print " " >> /tmp/sysinfo.$$.logfile.info
  print " "

  f_display_file /tmp/sysinfo.$$.logfile.info
  f_display_file /tmp/sysinfo.$$.logfile.warn

  return $return_code
}



################################################################################
# Function:    LookupName()
# Description: Lookup the full name for a specified hostname.  Uses nslookup.
# Arguments:   <hostname, domainname or address>
# Output:      fully qualified hostname
# Returns:     0: successfully determined name
#              1: unable to find name (using /etc/hosts)
#              2: unable to find name (using name server)

LookupName() {

#   if [ $# -ne 1 ]
#   then
#       Panic "${0}: expect <hostname|address> argument"
#   fi

    #nslookup "$1" > $_TMP 2>&1
    # Return 0 if name found, 1 if not found and using /etc/hosts,
    # 2 if not found and using some sort of name server.
    #
    nslookup "$1" 2>&1 | 
    awk '
         BEGIN              { ret_val=2 }
         $0 ~ "/etc/hosts"  { ret_val=1 }
         $1 == "Name:"      { print $2; ret_val=0 }
         END                { exit (ret_val) }
        ' $_TMP
    return_value=$?
    case $return_value in
      0)  return_string="found using nslookup";;
      1)  return_string="found in /etc/hosts/";;
      2)  return_string="not found";;
    esac
    Debug "  return from LookupName = $return_value ($return_string)"
    return $return_value

}

################################################################################
# GetCurrentDNS()
GetCurrentDNS() {

### Changed 6/16/99 J.Semroc - allows for possibility of multiple nameservers,
###                            domain search directive, and possibility that
###                            no domain is specified
### <ST> 07/12/99 - added -s option to cut in case nslookup does not return
###          fully qualified name.  
###          added ^ to nameserver to ignore commented entries

    if [ -f $RESOLV_CONF ]
    then
      CURRENT_DOMAIN=$(nslookup ${sysname} | grep "^Name: " | \
            awk -F: '{print $2}'| cut -s -d. -f2- )
      if [[ -z ${CURRENT_DOMAIN} ]]
      then
        Debug "Could not find domain using nslookup - checking resolv.conf"
# Extract the domain from resolv.conf
        set -- $(awk '
          $1 == "domain"     { DOMAIN=$2 }
          $1 == "nameserver" { ADDRESS=$2 ; exit }
          END { printf "%s %s\n", DOMAIN, ADDRESS }' $RESOLV_CONF)
        CURRENT_DOMAIN="$1"
      else
        Debug "Found domain using nslookup"
      fi

### Extract the  address and name of nameserver from resolv.conf
###     if [ $# -eq 2 ]
###     then
###         # See if we can get a name for the nameserver
###         CURRENT_DOMAIN="$1"
###         CURRENT_DNS_SERVER_IP="$2"
###         CURRENT_DNS_SERVER=$(LookupName $CURRENT_DNS_SERVER_IP)
###         if [ -z "$CURRENT_DNS_SERVER" ]
###         then
###             CURRENT_DNS_SERVER=unknown
###         fi
###     else
###         unset CURRENT_DOMAIN CURRENT_DNS_SERVER_IP CURRENT_DNS_SERVER
###    fi

      CURRENT_DNS_SERVER_IP=$(for server in `grep ^nameserver \
              ${RESOLV_CONF} | awk '{print $2}'`
               do
                  print -n $server"  "
               done | awk '{ print $1}')
      CURRENT_DNS_SERVER=$(LookupName `echo ${CURRENT_DNS_SERVER_IP} \
              | awk '{ print $1}' `)
    fi

}

#===================================================================
# weed_targets
#
# Scan the output from ioscan and filter out all SCSI "target"
# lines.  Also filter out entries with a low_level driver of "root"
#===================================================================
weed_targets()
{
    awk -F: '
        {
            class  = $9;
            low_level_driver = $10
            if (class != "target" && low_level_driver != "root")
                print $0
        }' -
}


#==================================================================
# This routine invokes ioscan with any passed in arguments and
# generates the above mentioned colon separated output. Note that
# all lines begin and end with colons. This makes for easy parsing
# of the output to match specific fields via grep.
#===================================================================
formatter()
{
    awk -F: '
        {
#=====================================================================
# Not all of the fields of ioscan output are used by SAM.
# They are all listed here for documentation purposes.
#=====================================================================
#       bus_type               = $1
        cdio                   = $2
#       is_block               = $3
#       is_char                = $4
#       is_pseduo              = $5
#       block_major_number     = $6
#       character_major_number = $7
#       minor_number           = $8
        class                  = $9
#       low_level_driver       = $10
        full_hw                = $11
        identify_bytes         = $12
#       device instance        = $13
#       module_path            = $14
        driver                 = $15
        sw_status              = $16
#       hardware_type          = $17
        ident                  = $18
        instance               = $19
        num_hw   = split(full_hw, hw_path, ".");
        address = "";
        unit    = "";
#============================================================
#
# Identifying bytes for PA Modules contain this information:
#
#  Byte
#  Address   Name            Description
#  --------- --------------- --------------------------------------
#  0-1       IODC_HVERSION   Hardware version number
#  2         IODC_SPA        Soft physical address capability
#  3         IODC_TYPE       Type of module
#  4-7       IODC_SVERSION   Software version number
#  8         IODC_REV        IODC revision
#  9         IODV_DEP        HVERSION dependent
#  10-11     RESERVED
#  12-13     IODC_CHECK      Checksum
#  14-15     IODC_LENGTH     Length of entry point table
#
#============================================================

        split(identify_bytes, id_flds, " ");
        hversion= (((((id_flds[1]*256)+id_flds[2])*256)+id_flds[3])*256)+id_flds[4];
        sversion= (((((id_flds[5]*256)+id_flds[6])*256)+id_flds[7])*256)+id_flds[8];
        if ( id_flds[9] != "" ) {
                device_id = id_flds[9] " " id_flds[10] " " id_flds[11] " " id_flds[12] " " id_flds[13] " " id_flds[14] " " id_flds[15] " " id_flds[16];
        }
        else {
                device_id = "";
        }
        #
        # Specifically for multi path environments (FiberChannel),
        # save the driver and last 8 bytes of the identify_bytes
        # of this device ("ext_bus" class; parent of actual devices)
        # tacking on to actual devices later.
        #
        if ( class == "ext_bus") {
           if ( ( identify_bytes != "") && (( driver == "fcpmux") || ( driver == "fcpdev"))) {
                parent_driver = driver;
                parent_id = device_id;
           }
           else {
                parent_driver=""
                parent_id=""
           }
        }

        #
        # Set driver to "?" if not known
        #
        if ((substr(driver, 1, 1) == "?") || (driver == "pdn0") ||
            (driver == ""))
        {
            #
            # SPECIAL CASES FOR NON-AUTOCONFIGURABLE DEVICES
            # Check the hardware identifier field, if it matches
            # a non-autoconfigurable device and there is no driver
            # bound to the device, fill in the driver field with the
            # appropriate driver name flag to true
            #
#
# Change this to use the device description.
#
            if (ident == "0x2080") {
                driver = "pdn0";
            }
#
# Change this to use the device description.
#
            else if (ident == "0x2f80") {
                driver = "pdn0";
            }

            else if ((substr(driver, 1, 1) == "?") || (driver == "")) {
                driver = "?";
            }

            not_configured = 1;
        } else
            not_configured = 0;

        if (sw_status != "CLAIMED")
                not_configured = 1;

        if ((driver == "tape1") || (driver == "tape2")      ||
            (driver == "lpr0")  || (driver == "lpr1")       ||
            (driver == "disc3") || (driver == "sflop")      ||
            (driver == "schgr") || (driver == "autox0")     ||
            (driver == "cs80")  || (driver == "sdisk")      ||
            (driver == "stape") || (driver == "disc4")) {
          address = hw_path[num_hw-1];
          unit    = hw_path[num_hw];
        }
        else if ((driver == "disc1") || (driver == "disc2") ||
                 (driver == "instr0")|| (driver == "pflop")) {
          address = hw_path[num_hw];
        }


#       printf(":%s:%s:%s:%s:%s:%s:%d:%s:0x%x;0x%x:%s:%s:%s:%s:\n",
#           cdio, driver, instance, full_hw, address, unit,
#           not_configured, sw_status, sversion, hversion, ident,
#           device_id, parent_driver, parent_id );
        printf("%22s %12s  %s\n", full_hw, driver, ident );
    }' -
} # end of formatter

#===========================================================
# lvm_scan
#===========================================================
function lvm_scan
{
  # first get all volume groups, logical volumes & physical volumes
  vgdisplay -v 2>&1 | \
  awk '
    BEGIN             { vgprinted = ""; onpvg = ""; numpvgs = 0
                      }
    /^VG Name/        {
                          vg = substr($3, 6, length($3) - 5);
                          vgprinted = ""; onpvg = ""; numpvgs = 0;
                          freepe_count = 0; next;
                      }
    /VG Write Access/ {
                           vgwrite = $4;
                           next;
                      }
    /VG Status/       {
                         vgstatus = "";
                         for(i=3;i<=NF;i++)
                            vgstatus = vgstatus $i;
                         vgstatus = vgstatus "," vgwrite "@";
                           next;
                     }
    $2 == "Server"   {
                         vgstatus = vgstatus $1;
                           next;
                     }
    $2 == "Client"   {
                         vgstatus = vgstatus ",";
                         vgstatus = vgstatus $1;
                           next;
                     }
    /Max LV/         { maxlv = $3; next;  }
    /Max PV/         { maxpv = $3; next;  }
    /Cur LV/         { numlvs = $3; next; }
    /Cur PV/         { numpvs = $3; next; }
    /PE Size/        { pesize = $4; next; }
    /Max PE per PV/  { maxpe = $5; next;  }
    /Total PVG/      { numpvgs = $3; next; }
    /LV Name/        {
                       if (vgprinted == "")
                       {
                         printf("VG:%s:%s:%s:%s:%s:%s:%s:%s:%s:%s:%s::::::\n",
                                 vg, vgstatus, maxlv, maxpv, numlvs,
                                 numpvs, numpvgs, pesize, maxpe,
                                 totalpe * pesize, freepe * pesize);
                         vgprinted = "y";
                       }
                       printf("LV:%s:::::::%s::::%s:::::\n",
                               vg, pesize, $3);
                       next;
                     }
    /Alternate Link$/ {
                       if (onpvg == "")
                       {
                         if (vgprinted == "")
                         {
                           printf("VG:%s:%s:%s:%s:%s:%s:%s:%s:%s:%s:%s::::::\n",
                                   vg, vgstatus, maxlv, maxpv, numlvs,
                                   numpvs, numpvgs, pesize, maxpe,
                                   totalpe * pesize, freepe * pesize);
                           vgprinted = "y";
                          }
                          printf("ALT:%s::::::::::::%s:%s:::\n", vg, pv, $3);
                        }
                        next;
                      }
    /PV Name/         {
                        pv = $3;
                        if (onpvg == "")
                        {
                          if (vgprinted == "")
                          {
                           printf("VG:%s:%s:%s:%s:%s:%s:%s:%s:%s:%s:%s::::::\n",
                                   vg, vgstatus, maxlv, maxpv, numlvs,
                                   numpvs, numpvgs, pesize, maxpe,
                                   totalpe * pesize, freepe * pesize);
                           vgprinted = "y";
                          }
                        }
                        else
                        {
                          printf("PV:%s::::::::::::%s::::%s\n",vg, pv, pvg);
                          pvg = "";
                        }
                        next;
                      }
    /Free PE/         {
                        freepe = $3;
                        if (freepe_count > 0)
                        {
                          printf("PV:%s::::::::::::%s::%s:%s:\n", 
                                  vg, pv, totalpe, freepe);
                        }
                        freepe_count ++;
                        next;
                      }

  ' >>   /tmp/sysinfo.vg.tmp
  mv  /tmp/sysinfo.vg.tmp  $vg_list_file
#
# now get list of all logical volumes
#
  awk ' BEGIN           { FS = ":" }
      { type = $1; vgstatus = $2;  pesize = $8;
        if (type == "LV") 
        {
          printf ("%s\n",$13)
        }
      }
  ' $vg_list_file  >> /tmp/sysinfo.lvol.list.tmp
  sort  /tmp/sysinfo.lvol.list.tmp > $lvol_list_file
  rm -f /tmp/sysinfo.lvol.list.tmp
#
# now get details on each logical volume
#
  lvol_list=$(cat $lvol_list_file)
  for lvol in $lvol_list
  do
  
    lvdisplay $lvol 2>&1 | \
    awk '
        BEGIN                  { mwc = 0;
                                 nummir = 0;
                                 mircon = 0;
                                 bbr = 0;
                                 conalloc = 0 ;
                                 numstripes = 0;
                                 stripesize = 0 }
        /LV Name/              { lvname= $3; next }
        /LV Permission/        { perm = $3; next }
        /Mirror copies/        { nummir = $3; next }
        /Consistency Recovery/ { mwc = $3; next }
        /Schedule/             { sched = $2; next }
        /LV Size/              { size = $4; next }
        /Current LE/           { les = $3; next }
        /Bad block/            { if ($3 == "on") bbr = 1; badblock = $3;
                                 if (badblock == "NONE")
                                   badblock = "NO";
                                 next }
        /Allocation/           { alloc=$2;
                                if (alloc == "non-strict")
                                   alloc = "ns";
                                if (alloc == "non-strict/contiguous")
                                   alloc = "ns-c";
                                if (alloc == "strict")
                                   alloc = "s";
                                if (alloc == "strict/contiguous")
                                   alloc = "s-c";
                                if (alloc == "PVG-strict")
                                   alloc = "PVG";
                                if (alloc == "PVG-strict/contiguous")
                                   alloc = "PVG-c";
                                if (alloc == "PVG-strict/distributed")
                                   alloc = "PVG-d";
                                if (alloc == "PVG-strict/partially-distributed")
                                    alloc = "PVG-p";
                                  next;
                               }
        /LV Status/            { state = $3; 
                                 if (state == "available/stale")
                                     state = "stale";
                                 if (state == "available/syncd")
                                     state = "syncd";
                                 if (state == "available")
                                     state = "avail";
                                 if (state == "unavailable")
                                     state = "unavl";
                                next }
        /Stripes/              { numstripes = $2; next }
        /Stripe Size/          { stripesize = $4; next }

                               {next}
        END                    {
                                   if ( size == 0 )
                                   {
                                       pesize = size;
                                   }
                                   else
                                   {
                                       pesize = size / les;
                                   }

                            printf("%-32s %5s %3s %4s %4s %6s %6s  %-5s %-5s\n", 
                                lvname, size, numstripes,
                                stripesize, nummir, mwc, state, badblock,alloc)
                               }
    ' >> /tmp/sysinfo.lvol.data.tmp
  done
  mv /tmp/sysinfo.lvol.data.tmp  $lvol_out_file
  rm -f /tmp/sysinfo.lvol.data.tmp
#
# now get list of all physical volumes
#
  awk ' BEGIN           { FS = ":" }
      { type = $1; vgstatus = $2;  pesize = $8;
        if (type == "PV") 
        {
          printf ("%s\n",$14)
        }
      }
  ' $vg_list_file >> /tmp/sysinfo.pvol.list.tmp
  sort  /tmp/sysinfo.pvol.list.tmp > $pvol_list_file
  rm -f /tmp/sysinfo.pvol.list.tmp
#
# now get details on each physical volume
#
  pvol_list=$(cat $pvol_list_file)
  for pvol in $pvol_list
  do
    pvdisplay -v $pvol 2>&1 | \
    awk '
        BEGIN               {found=0}

        /PE Size/           {pesize = $4; next}
        /LV Name/           {found=1; next}
        /Physical extents/  {exit 0}

        #
        # Print "LV_Name Logical_MB_of_LV Physical_MB_of_LV"
        #
        {
            if (found && NF == 3)
                printf("%s:%d:%d\n", $1, $2 * pesize, $3 * pesize)
        }
    ' -  >> $pvol_out_file
     
  done
}  # end of lvm_scan

#===========================================================
function launch_lvm_scan
#===========================================================
{
  Debug "Building $lvm_scan_command_file"

  rm -f $lvm_scan_done 

  Debug "$vg_out_file, $vg_list_file, $lvol_out_file"
  Debug "$lvol_list_file, $pvol_list_file $pvol_out_file"
  Debug "$lvm_scan_done"

  cat <<==end_of_command==   > $lvm_scan_command_file

    # now call the lvm_scan function (exported from parent)
    lvm_scan
    date > \$lvm_scan_done

==end_of_command==

  chmod +x $lvm_scan_command_file
  Debug "  launching $lvm_scan_command_file"
  $lvm_scan_command_file &
  Debug "  parent PID = $$, child PID = $!"

}  # end of launch_lvm_scan

#===========================================================
# launch_kernel_scan
#===========================================================
function launch_kernel_scan
{
  Debug " Starting launch_kernel_scan.....building $kernel_scan_command_file"

  # change filenames to send output to parent's PID
  rm -f $kernel_scan_done 

  Debug "$kernel_kinfo $kernel_out_file"
  Debug "$kernel_scan_done"

  cat <<==end_of_command==   > $kernel_scan_command_file

    # now call the sam_scan function (exported from parent)
    kernel_scan
    date > \$kernel_scan_done

==end_of_command==

  chmod +x $kernel_scan_command_file
  Debug "  launching $kernel_scan_command_file"
  $kernel_scan_command_file &
  Debug "  parent PID = $$, child PID = $!"


}  # end of launch_kernel_scan

#===========================================================
# launch_io_scan
#===========================================================
function launch_io_scan
{
  Debug " Starting launch_io_scan.....building $io_scan_command_file"

  # change filenames to send output to parent's PID
  rm -f $io_scan_done

  Debug "$io_scan_done"

  if (( ${osmajor} >= 10 ))
  then
    cat <<==end_of_command==   > $io_scan_command_file

    # now call the io_scan function (exported from parent)
      io_scan
      date > \$io_scan_done
==end_of_command==

    chmod +x $io_scan_command_file
    Debug "  launching $io_scan_command_file"
    $io_scan_command_file &
    Debug "  parent PID = $$, child PID = $!"
  else
    Debug "  on 9.x - executing ioscan"
    print    "H/W Path      LU       Driver" >> ${io_scan_out}
    print -- "-----------------------------" >> ${io_scan_out}
    ioscan -f | tail +3 | \
      awk '{printf ("%-14s %-6s %-20s\n", $3, $2, $4)}' \
      >> ${io_scan_out}
    date > $io_scan_done
  fi

}  # end of launch_io_scan



#===========================================================
# check_if_scan_done
#===========================================================
function check_if_scan_done
{
  scan_type=$1
  done_file=/tmp/sysinfo.$$.${scan_type}_done
  Debug "  starting check_if_scan_done for ${scan_type}."
  Debug "  looking for /tmp/sysinfo.$$.${scan_type}_done"
  if (($BATCH))
  then
    print -n "retrieving ${scan_type} data "
  fi
  if [ ! -f ${done_file} ]     # enter time out loop
  then
    Debug "  ${scan_type}_done file not ready, entering loop."
    FORCE="TRUE"
    for fil in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
    do
### Changed 6/15/99 J.Semroc - allow more time for large systems
###   sleep 5
      sleep 60
### end of Change
      Debug "    in loop $fil"
      if (($BATCH))
      then
        print -n "."
      fi
      if [ -f ${done_file} ]
      then
        Debug "  ${scan_type} done."
        FORCE="FALSE"
        break
      fi
    done
    if [ "$FORCE" = "TRUE" ]
    then
      Debug "  still no file, forcing an interactive ${scan_type}."
      ${scan_type}
    fi
  else
    Debug "  found ${scan_type}_done file"
    if (($BATCH))
    then
      print ""
    fi
  fi
}

#===========================================================
# io_scan
#
# this routine runs ioscan with the appropriate parameters and
# places the output in /var/sam/<sysname>.iout   It also
# provides a semaphore for other asyncronous processes, by removing
# and then creating /var/sam/<sysname>.dion
#
#===========================================================
function io_scan
{

#       bus_type               = $1
#       cdio                   = $2
#       is_block               = $3
#       is_char                = $4
#       is_pseduo              = $5
#       block_major_number     = $6
#       character_major_number = $7
#       minor_number           = $8
#       class                  = $9
#       low_level_driver       = $10
#       full_hw                = $11
#       identify_bytes         = $12
#       device instance        = $13
#       module_path            = $14
#       driver                 = $15
#       sw_status              = $16
#       hardware_type          = $17
#       ident                  = $18
#       instance               = $19

#
#  If an inadaquate description is given from ioscan.  Initiate a diskinfo
#  request to force an open operation and then perform another ioscan for
#  that device.  If the diskinfo operation results in an error containing
#  "Permission Denied" the device may be a tape drive needing a slightly
#  different device file.  At the time of this modification to this script
#  (7/5/94) an HPFL Disc will only give a useful description when there is
#  a mounted file system on the disk.
#
#  Change the Internal Field Separator to ":".  All output fields of
#  ioscan -F are separated by a ":".
#
  LANG=$save_lang
  LANG=C
  rm -f $io_scan_done
  ioscan $ioscan_args > $io_scan_tmp
  mv $io_scan_out $io_scan_out.old > /dev/null 2>&1
  ifs_save=$IFS
  IFS=:
  cat $io_scan_tmp | \
  while read p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14 p15 p16 p17 p18 p19
  do
      if [ "$p18" = "HP-IB Device" -o "$p18" = "HP-IB Tape" -o \
           "$p18" = "SCSI Tape"    -o "$p18" = "HPFL Disc" ]
      then
          mksf -r -H $p11 /var/sam/sam_tmp >/dev/null 2>&1
          diskinfo /var/sam/sam_tmp >/dev/null 2>/var/sam/sam_err
          if ( grep Permission /var/sam/sam_err >/dev/null 2>&1 )
          then
              mksf -r -c -u 0 -H $p11 /var/sam/sam_tmp >/dev/null 2>&1
              diskinfo /var/sam/sam_tmp >/dev/null 2>&1
          fi
          ioscan -H $p11 -F >>$io_scan_out 2>/dev/null
          rm -f /var/sam/sam_tmp /var/sam/sam_err
      else
          echo "$p1:$p2:$p3:$p4:$p5:$p6:$p7:$p8:$p9:$p10:$p11:$p12:$p13:$p14:$p15:$p16:$p17:$p18:$p19" >>$io_scan_out
      fi
  done
  IFS=$ifs_save
  date > $io_scan_done
  rm $io_scan_tmp

} #end of io_scan

#==================================================================
# sw_scan
#==================================================================
function sw_scan
{
  Debug "Beginning SW_SCAN"
  if [[ -f /usr/sbin/swlist ]]
  then
    Debug "  found swlist"
    if (($HTML))
    then
      print "</PRE>"                  >> /tmp/sysinfo.$$.swout
      print "<A name='Software'></A>" >> /tmp/sysinfo.$$.swout
      print "<H2>"                    >> /tmp/sysinfo.$$.swout
      print "<P ALIGN=RIGHT><A HREF='#Top'>TOP</A></P>" >> /tmp/sysinfo.$$.swout
      print "<FONT COLOR=red>" >> /tmp/sysinfo.$$.swout
      print "Software Data</FONT></H2>"  >> /tmp/sysinfo.$$.swout
      print "<PRE><font size = '4'>"  >> /tmp/sysinfo.$$.swout
    else
      print "" >> /tmp/sysinfo.$$.swout
      print "SOFTWARE DATA" >> /tmp/sysinfo.$$.swout
      print "=============" >> /tmp/sysinfo.$$.swout
    fi
  if (($BATCH))
  then
    print  "collecting software data "
  fi
    print    "Product                Version         Description" >> /tmp/sysinfo.$$.swout
    print -- "--------------------------------------------------" >> /tmp/sysinfo.$$.swout
    swlist -l product | grep -v "^#" | expand >> /tmp/sysinfo.$$.swout
    f_display_file /tmp/sysinfo.$$.swout
    #check for non-configured software
    print  "checking for incompletely installed software "
    swlist -l fileset -a state | grep -e transient -e corrupt \
            -e available -e installed | expand >> /tmp/sysinfo.$$.sw_not_conf
    if [[ -s /tmp/sysinfo.$$.sw_not_conf ]]
    then
      print "" >> /tmp/sysinfo.$$.sw_not_header
      print "Found incompletely installed filesets" >> \
                /tmp/sysinfo.$$.sw_not_header
      print "=====================================" >> \
                /tmp/sysinfo.$$.sw_not_header
      print "WARNING (${sysname}): Found incompletely installed software." >> \
             /tmp/sysinfo.$$.errwarn
      f_display_file /tmp/sysinfo.$$.sw_not_header
      f_display_file /tmp/sysinfo.$$.sw_not_conf
    fi
  else
  Debug " could not find swlist."
  fi
}

#==================================================================
#f_build_sched_file
#        This function retrieves the os version information and
#        series type. It then sets the kernel pointers.
#===================================================================
function f_build_sched_file
{
  Debug "Beginning build_sched_file"
cat <<==end_of_file==   >  ${where}/sched.models
600     1.0     PA7000
635     1.0     PA7000
645     1.0     PA7000
700     1.1     PA7000
705     1.1a    PA7000
715     1.1c    PA7100LC
710     1.1a    PA7000
712     1.1c    PA7100LC
720     1.1a    PA7000
722     1.1c    PA7100LC
725     1.1c    PA7100LC
728     1.1d    PA7200
730     1.1a    PA7000
735     1.1b    PA7100
742     1.1b    PA7100
743     1.1c    PA7100LC
744     1.1e    PA7300
745     1.1b    PA7100
747     1.1b    PA7100
750     1.1a    PA7000
755     1.1b    PA7100
770     1.1d    PA7200
777     1.1d    PA7200
778     1.1e    PA7300
779     1.1e    PA7300
780     2.0     PA8000
781     2.0     PA8000
782     2.0     PA8200
785     2.0     PA8500
800     1.0     PA7000
801     1.1c    PA7100LC
802     2.0     PA8000
803     1.1e    PA7300
804     2.0     PA8000
806     1.1c    PA7100LC
807     1.1a    PA7000
808     1.0     PA7000
809     1.1d    PA7200
810     2.0     PA8000
811     1.1c    PA7100LC
813     1.1e    PA7300
815     1.0     PA7000
816     1.1c    PA7100LC
817     1.1a    PA7000
819     1.1d    PA7200
820     2.0     PA8000
821     1.1d    PA7200
822     1.0     PA7000
825     1.0     PA7000
826     1.1c    PA7100LC
827     1.1a    PA7000
829     1.1d    PA7200
831     1.1d    PA7200
832     1.0     PA7000
834     1.0     PA7000
835     1.0     PA7000
837     1.1a    PA7000
839     1.1d    PA7200
840     1.0     PA7000
841     1.1d    PA7200
842     1.0     PA7000
845     1.0     PA7000
847     1.1a    PA7000
849     1.1d    PA7200
850     1.0     PA7000
851     1.1d    PA7200
852     1.0     PA7000
855     1.0     PA7000
856     1.1c    PA7100LC
857     1.1a    PA7000
859     1.1d    PA7200
860     1.0     PA7000
861     2.0     PA8000
865     1.0     PA7000
867     1.1a    PA7000
869     1.1d    PA7200
870     1.0     PA7000
871     2.0     PA8000
877     1.1a    PA7000
879     2.0     PA8000
887     1.1b    PA7100
889     2.0     PA8000
890     1.0     PA7000
891     1.1b    PA7100
892     1.1b    PA7100
893     2.0     PA8000
897     1.1b    PA7100
898     2.0     PA8200
899     2.0     PA8200
F10     1.1a    PA7000
F20     1.1a    PA7000
H20     1.1a    PA7000
F30     1.1a    PA7000
G30     1.1a    PA7000
H30     1.1a    PA7000
I30     1.1a    PA7000
G40     1.1a    PA7000
H40     1.1a    PA7000
I40     1.1a    PA7000
G50     1.1b    PA7100
H50     1.1b    PA7100
I50     1.1b    PA7100
G60     1.1b    PA7100
H60     1.1b    PA7100
I60     1.1b    PA7100
G70     1.1b    PA7100
H70     1.1b    PA7100
I70     1.1b    PA7100
E25     1.1c    PA7100LC
E35     1.1c    PA7100LC
E45     1.1c    PA7100LC
E55     1.1c    PA7100LC
T500    1.1b    PA7100
T520    1.1b    PA7100
T540    2.0     PA8000
T600    2.0     PA8000
K100    1.1d    PA7200
K200    1.1d    PA7200
K210    1.1d    PA7200
K220    1.1d    PA7200
K230    1.1d    PA7200
K400    1.1d    PA7200
K410    1.1d    PA7200
K420    1.1d    PA7200
DXO     1.1c    PA7100LC
DX0     1.1c    PA7100LC
DX5     1.1c    PA7100LC
D200    1.1c    PA7100LC
D210    1.1c    PA7100LC
D310    1.1c    PA7100LC
D410    1.1d    PA7200
D250    1.1d    PA7200
D350    1.1d    PA7200
J200    1.1d    PA7200
J210    1.1d    PA7200
C100    1.1d    PA7200
J220    2.0     PA8000
J280    2.0     PA8000
J282    2.0     PA8000
S715    1.1e    PA7300
S760    1.1e    PA7300
D650    2.0     PA8000
J410    2.0     PA8000
J400    2.0     PA8000
J210XC  1.1d    PA7200
J2240   2.0     PA8200
J5000   2.0     PA8500
J5600   2.0     PA8600
J6000   2.0     PA8600
J7000   2.0     PA8500
C200+   2.0     PA8200
C240+   2.0     PA8200
C360    2.0     PA8500
C180    2.0     PA8000
C180-XP 2.0     PA8000
C160    2.0     PA8000
C160L   1.1e    PA7300
C140    2.0     PA8000
C130    2.0     PA8000
C120    1.1e    PA7300
C115    1.1e    PA7300
C110    1.1d    PA7200
B160L   1.1e    PA7300
B132L   1.1e    PA7300
B120    1.1e    PA7300
B115    1.1e    PA7300
B1000   2.0     PA8500
B2000   2.0     PA8500
C3000   2.0     PA8500
C3600   2.0     PA8600
S700i   1.1e    PA7300
S744    1.1e    PA7300
D330    1.1e    PA7300
D230    1.1e    PA7300
D320    1.1e    PA7300
D220    1.1e    PA7300
D360    1.1d    PA7200
K360    2.0     PA8000
K370    2.0     PA8200
K460    2.0     PA8000
K460-EG 2.0     PA8000
K460-XP 2.0     PA8000
K260    2.0     PA8000
K260-EG 2.0     PA8000
D260    1.1d    PA7200
D270    2.0     PA8000
D280    2.0     PA8000
D370    2.0     PA8000
D380    2.0     PA8000
D390    2.0     PA8000
R380    2.0     PA8000
R390    2.0     PA8000
K250    2.0     PA8000
K450    2.0     PA8000
K270    2.0     PA8200
K470    2.0     PA8200
K380    2.0     PA8200
K580    2.0     PA8200
V2200   2.0     PA8200
V2250   2.0     PA8200
V2500   2.0     PA8500
V2600   2.0     PA8600
L1000-36  2.0   PA8500
L1000-44  2.0   PA8500
L2000-36  2.0   PA8500
L2000-44  2.0   PA8500
N4000-36  2.0   PA8500
N4000-44  2.0   PA8500
A180    1.1     PA7300LC
A180C   1.1     PA7300LC

==end_of_file==

chmod 444 ${where}/sched.models
}

#==================================================================
#f_get_sys_type
#        This function retrieves the os version information and
#        series type. It then sets the kernel pointers.
#===================================================================
function f_get_sys_type
{
  Debug "Beginning GET SYSTEM TYPE"
  osletter=$(uname -r | awk -F. '{print $1}')
  osmajor=$(uname -r | awk -F. '{print $2}')
  osminor=$(uname -r | awk -F. '{print $3}')
  system=$(uname -m | awk -F/ '{print $1}')
  series=$(uname -m | awk -F/ '{print $2}')
  machine_id=$(uname -i)
  license=$(uname -l)
  Debug "  `uname -a`"
  Debug "  system = $system"
  Debug "  series = $series"
  Debug "  OS = $osletter.$osmajor.$osminor"
  Debug "  machine = $machine_id"
  Debug "  license = $license"
  if (( `echo $series | cut -b1` == 7 )) && (( $osmajor <= 9 ))
  then
    print "\nSorry. Not supported on Series 700 running HP-UX 9.x\n"
    exit ${ERROR}
  fi
  if [[ ! -z $(whence model) ]]
  then
    series=`model`
    Debug "  model returned $series"
    sched_file=${where}/sched.models
    f_build_sched_file
    pa_ver="N/A"
    pa_chip="N/A"
    if [[ -f ${sched_file} ]]
    then
      check_pa=$(model | awk -F/ '{print $NF}')
      pa_ver=$(grep "${check_pa} " $sched_file | awk '{print $2}')
      pa_chip=$(grep "${check_pa} " $sched_file | awk '{print $3}')
    else
      pa_ver=""
      pa_chip=""
    fi
  else
    Debug "  model not found, using inline series check"
    case $series in
      780) series="780/C160";;
      801) series="801/DX0";;
      811) series="811/DX5";;
      806) series="806/E25";;
      807) series="807/F10";;
      809) series="809/K100";;
      816) series="816/E35";;
      817) series="817/F20";;
      819) series="819/K200";;
      821) series="821/D200/D400";;
      826) series="826/E45";;
      827) series="827/H20";;
      829) series="829/K400";;
      831) series="831/D200/D400";;
      837) series="837/F30";;
      839) series="839/K210";;
      841) series="841/D210/D410";;
      847) series="847/G30/H30";;
      851) series="851/D210/D410";;
      849) series="849/K410";;
      856) series="856/E55";;
      857) series="857/I30";;
      859) series="859/K220";;
      867) series="867/G40/H40";;
      869) series="869/K420";;
      877) series="877/I40";;
      887) series="887/G50/H50/G60/H60/G70/H70";;
      890) series="890";;
      891) series="891/T500";;
      892) series="892/T520";;
      897) series="897/I50/I60/I70";;
        *) series=$series
             Debug "Series type not found for $series" ;;
    esac
  fi
  if [ $osmajor -lt 10 ]
  then
    kernel=/hp-ux
  else
    kernel=/stand/vmunix
  fi
  Debug "  kernel=${kernel}"
  if [[ -f /etc/lvmtab ]]
  then
    lvm_installed=1
    Debug "  LVM Detected."
  else
    lvm_installed=0
    Debug "  LVM NOT Detected."
  fi
# set PATH variable to ensure access to required commands
  for i in \
    /etc \
    /usr/sbin \
    /bin \
  ; 
  do
    if [ -d $i ]
    then
      PATH=$PATH:$i
    fi
  done
  export PATH
  Debug "  PATH = $PATH"
  if [ -f ${where}/system_db ]
  then
    conf_file=${where}/system_db
  elif [ -f /usr/local/bin/system_db ]
  then
    conf_file=/usr/local/bin/system_db
  fi
  if [[ -n ${conf_file} ]]
  then
    Debug "  Found config file = $conf_file"
    serial_number=$(grep $sysname $conf_file | awk -F: '{print $4}')
    Debug "    serial number = ${serial_number}"
  fi
  swap_devs=$(swapinfo -d | grep -v "Kb" |grep -v "TYPE" \
         | awk '{printf "%s ", $NF}')
# if (($FULL_KERNEL)) || (( ${LITE_KERNEL} ))
# then
#   if (( ${osmajor} >= 10 ))
#     rm -f $kernel_scan_done
#     launch_kernel_scan
#     Debug "Calling kernel_scan"
#     if (($BATCH))
#     then
#       print "launching background kernel scan"
#     fi
#   fi
# fi
  if (($IOSCAN)) || (($PHYSICAL))
  then
    rm -f $io_scan_done
    launch_io_scan $ioscan_args
    Debug "Calling io_scan"
    if (($BATCH))
    then
      print "launching background ioscan"
    fi
  fi
  if (($LVMSCAN))
  then
    rm -f $lvm_scan_done
    launch_lvm_scan
    Debug "Calling launch_lvm_scan"
    if (($BATCH))
    then
      print "launching background lvm scan"
    fi
  fi
}                # end of f_get_sys_type

#===================================================================
#
#===================================================================
function f_run_cstm
{
cstm_ok=0
print -n "Checking digmond...."

diagmond_result=$(ps -ef | grep -v grep | grep  diagmond > /dev/null 2>&1)
diagmond_result=$?
if (($diagmond_result != 0))
then
  cstm_ok=1
  Debug "Error: diagmond is not running."
  Debug "diagmond_result = $diagmond_result"
  print "diagmond is NOT running!"
  print "No cstm info is available."
  return
else
  print "diagmond is running."
fi

print -n "Checking cstm......."
cstm_version=$(echo "Version" | /usr/sbin/cstm | grep Version \
          | tail -1 |  awk '{print $2}' )
cstm_major=$(echo ${cstm_version} | awk -F. '{print $2}')

echo "Version" | /usr/sbin/cstm >/dev/null 2>&1
cstm_result=$?
if (($cstm_result != 0)) 
then
  cstm_ok=1
  Debug "Error returned from cstm"
  print "Error returned from cstm"
  print "cstm_result = $cstm_result"
fi

if (($cstm_ok == 0))
then
  cstm_version=$(echo "Version" | /usr/sbin/cstm | grep Version \
            | tail -1 |  awk '{print $2}' )
  cstm_major=$(echo ${cstm_version} | awk -F. '{print $2}')
  print "found version ${cstm_version}"
  ### Changed 6/30/99 J.Semroc also works with V14 
  ### if (($cstm_major >= 08))  && (($cstm_major <= 13))
  ###  and V16 <st>
  ### if (($cstm_major >= 08))  && (($cstm_major <= 16))
  ### Removed upper end version check on cstm <st>
  if (($cstm_major >= 08))
  ### end Change
  then
    print "Running cstm....please wait."
  
    if (($cstm_major == 12))
    then
      cat <<==end_of_command==   > ${cstm_command_file}
      # testtt
      #
      # The following connects the UI to the system the UI is being run on,
      #  and selects this system.
      # SelCurrentSys system add localhost  system 1
      # Use current user name
      # No password required on local system.
      # don't prompt for overwrite
      gop confirmation no
      #Select all
      #Select class cpu
      SelClass type processor qualifier cpu
      #collect the information and wait for it to finish
      Information ; wait
      #now display the info log
      #version 12 has SaveAs & Print Commands reversed.
      InfoLog
        Print
        $cstm_cpu_out
        Done
      #map
      unselall
      SelClass type memory
      Information ; wait
      InfoLog
        Print
        $cstm_mem_out
        Done
      unselall
      SelClass type disk
      Information ; wait
      InfoLog
        Print
        $cstm_disk_out
        Done
      Exit
      Ok
  
==end_of_command==
  
    else

      cat <<==end_of_command==   > ${cstm_command_file}
      # testtt
      #
      # The following connects the UI to the system the UI is being run on,
      #  and selects this system.
      #SelCurrentSys system add localhost  system 1
      # Use current user name
      # No password required on local system.
      #don't prompt for overwrite
      gop confirmation no
      #Select all
      #Select class cpu
      SelClass type processor qualifier cpu
      #collect the information and wait for it to finish
      Information ; wait
      #now display the info log
      InfoLog
        SaveAs
        $cstm_cpu_out
        Done
      #map
      unselall
      SelClass type memory
      Information ; wait
      InfoLog
        SaveAs
        $cstm_mem_out
        Done
      unselall
      SelClass type disk
      Information ; wait
      InfoLog
        SaveAs
        $cstm_disk_out
        Done
      Exit
      Ok
  
==end_of_command==
    fi
    /usr/sbin/cstm -f ${cstm_command_file} > /dev/null 2>&1

  awk '
      /Hardware path/         {path = $3; next;}
      /Slot Number/           {slot = $3; next; }
      /PDC Firmware Revision/ {pdc = $4; next;}
      /Instruction Cache/     {icache = $4; next;}
      /Data Cache/            {dcache = $4; next;}
      /Instruction TLB/       {itlb = $4; next;}
      /Data TLB/              {dtlb = $5;
                               printf("%6s%6s  %12s%8s %6s%6s %6s\n",
                               path, slot, pdc, icache, dcache, itlb, dtlb);
                              }
      ' $cstm_cpu_out > $cstm_cpu_out2

  rm -f ${cstm_command_file}
  #rm -f ${cstm_cpu_out}
  Debug "cstm_cpu_out2 = ${cstm_cpu_out2}"
  #Debug "Data Cache            = ${data_cache}"
  #Debug "Instruction Cache     = ${inst_cache}"
  #Debug "Data TLB              = ${data_cache}"
  #Debug "Instruction TLB       = ${inst_cache}"
  #Debug "PDC Firmware Revision = ${pdc_rev}"
  #Debug "${memory_interleave}"

    check_na=$(awk ' /Total Physical Memory/   {print $NF}
            ' $cstm_mem_out  | tail -1)
    if [[ ${check_na} != "N/A" ]]
    then
      cstm_tot_phys=$(awk ' /Total Physical Memory/   {print $(NF -1)}
        ' $cstm_mem_out  | tail -1)
    else
      cstm_tot_phys="N/A"
    fi
    cstm_tot_conf=$(awk ' /Total Configured Memory/  {print $(NF -1)}
        ' $cstm_mem_out  | tail -1)
    cstm_page_size=$(awk ' /Page Size/ {print $(NF -1)}
        ' $cstm_mem_out  | tail -1)
    cstm_interleave=$(awk ' /Memory interleaving/ { print $0}
        ' $cstm_mem_out | tail -1)
    if [[ -z ${cstm_tot_conf} ]] || [[ -z ${cstm_page_size} ]]
    then
      cstm_tot_conf="N/A"
      cstm_page_size="N/A"
    fi
  else
    print "Sorry, this version is not supported by SysInfo."
    print "Hardware level information will not be available."
    Debug "unsupported cstm version ${cstm_version}"
    cstm_ok=1
  fi
fi
} # end of function f_run_cstm


#===================================================================
# f_get_array_data
#===================================================================
function f_get_array_data
{
  if (( ${cstm_ok} == 0 ))
  then
    Debug "Getting array data"
    if (($cstm_major == 12))
    then
      cat <<==end_of_command==   > ${cstm_command_file}
      # testtt
      #
      # The following connects the UI to the system the UI is being run on,
      #  and selects this system.
      # SelCurrentSys system add localhost  system 1
      # Use current user name
      # No password required on local system.
      # don't prompt for overwrite
      gop confirmation no
      #unselall
      Sel path $hwpath
      Information ; wait
      InfoLog
        Print
        $cstm_array_out
        Done
      Exit
      Ok

==end_of_command==

    else   # cstm not equal to 12

      cat <<==end_of_command==   > ${cstm_command_file}
      # testtt
      #
      # The following connects the UI to the system the UI is being run on,
      #  and selects this system.
      #SelCurrentSys system add localhost  system 1
      # Use current user name
      # No password required on local system.
      #don't prompt for overwrite
      gop confirmation no
      #unselall
      Sel path $hwpath
      Information ; wait
      InfoLog
        SaveAs
        $cstm_array_out
        Done
      Exit
      Ok

==end_of_command==

    fi
    /usr/sbin/cstm -f ${cstm_command_file} > /dev/null 2>&1
    cat $cstm_array_out | tail +6 >> /tmp/sysinfo.$$.array
    rm $cstm_array_out
  else
    print "Array info not available  -  Problem with cstm."
  fi

} # end of f_get_array_data

#===================================================================
# f_get_system_data
#        This function retrieves various system  and boot data.
#        e.g. amount of memory, number of cpus, etc.
#        It also checks to see if memory dumping is properly
#        configured.
#===================================================================
function f_get_system_data
{
  if [[ (-f /usr/sbin/cstm) && (-x /usr/sbin/cstm) ]]
  then
    f_run_cstm 
  else
    cstm_ok=1
    Debug " cstm not found....skipping"
    print "WARNING (${sysname}): CSTM not installed." >> \
           /tmp/sysinfo.$$.errwarn
  fi
  Debug "Beginning SYSTEM/ROOT check."
  if (($BATCH))
  then
    print -n "collecting system data "
  fi
  # Determine cpu speed in MHz
  # Determine the memory size.
  # Real memory expressed in units of pages (4 kbytes per page).
  if [ ${osmajor} -eq 11 ]
  then
  cpu_speed=$(echo itick_per_tick/D | adb -k $kernel /dev/kmem | tail -1 \
          | awk '{print $2 / 10000}')
  REAL_MEM=$(echo 'phys_mem_pages/D'| adb -k $kernel /dev/kmem | tail -1 \
             | awk '{print $2}')
  MemoryDumpSize=$(expr ${REAL_MEM} / 256)
  k32_64=$(getconf KERNEL_BITS)
  processor_count=$(echo 'processor_count/D' | adb -k $kernel /dev/kmem \
                    | tail -1 | awk '{print $2}')
  else
  cpu_speed=$(echo itick_per_tick/D | adb $kernel /dev/kmem | tail -1 \
          | awk '{print $2 / 10000}')
  dumppages=$(echo 'dumpsize/D'| adb  $kernel /dev/kmem | tail -1 \
              | awk '{print $2}')
  MemoryDumpSize=$(expr ${dumppages} / 256)
  REAL_MEM=$(echo 'physmem/D'| adb  $kernel /dev/kmem | tail -1 \
             | awk '{print $2}')
  # determine number of active processors (cpus)
  processor_count=$(echo 'processor_count/D' | adb $kernel /dev/kmem \
                    | tail -1 | awk '{print $2}')
  fi
  memory=$(expr ${REAL_MEM} / 256)
  if (($BATCH))
  then
    print -n "."
  fi
  boot_time=$(who -b | awk '{printf "%s %s %s ", $4, $5, $6}')
   
  #now get date of last patch
  #
  #Modified: Greg Sterling
  #updated lastpatch for 10.x & 11.x
  #
  last_patch="unknown"
  if (( $osmajor >= 10 ))
  then
    if [ -d /var/adm/sw/products ]
    then
      last_patch=$(ls -lt /var/adm/sw/products | egrep 'PHNE|PHCO|PHKL|PHSS' \
           | head -1 | awk '{ print $6,$7,$8}')
    else
      Debug "ERROR: Product IPD database does not exist."
    fi
  else
    if [ -d /system ]
    then
      last_patch=$(ls -lt /system/ | egrep 'PHNE|PHCO|PHKL|PHSS' \
           | head -1 | awk '{ print $6,$7,$8}')
    fi
  fi
  if (($BATCH))
  then
    print -n "."
  fi
  if (($BATCH))
  then
    print -n "."
  fi
  lvlnboot -v /dev/vg00 > /tmp/sysinfo.$$.root 2>&1
  rootboot=$(grep "Boot Disk" /tmp/sysinfo.$$.root \
             | awk '{printf "%s  ", $1}')
  rootroot=$(grep "^Root:" /tmp/sysinfo.$$.root \
             | awk '{print $2,$4}')
  rootswap=$(grep "^Swap:" /tmp/sysinfo.$$.root \
             | awk '{print $2,$4}')
  rootdump=$(grep "^Dump:" /tmp/sysinfo.$$.root \
             | awk '{printf  "%s ",$2}')
  if (($BATCH))
  then
    print -n "."
  fi

  kernel_size=$(ll ${kernel} | awk '{print $5}' 2>&1)
# gather memory dump parms
  (( KernelSizeMb=`ll ${kernel} | awk '{print $5}'` / 1024 / 1024 + 1 ))
  if (( $osmajor < 10 ))
  then                                        
    # it is a 9.x system
    if [[ $(grep "dumps" /etc/conf/gen/S800*) = *default* ]]
    then
      DumpDiskCapacity=$(swapinfo -mat | grep dev | head -1 | awk '{print $2}')
      rootdump="default"
      Debug "  9.x system. default found in S800."
      Debug "  rootdump=${rootdump}"
    else
      Debug "  9.x system. default not found in S800. using rootdump"
    fi
    SAVECORE=0
    grep "/etc/savecore" /etc/rc > /dev/null 2>&1
    if ((! ($?) ))
    then
      SAVECORE=1
    fi
    SAVECORE_DIR=$(grep "/etc/savecore" /etc/rc | tail -1 | awk '{print $NF}')

  elif  (( $osmajor >= 11 ))
  then
    # 11.x system
    Debug "  11.x system."
    if [ -f /etc/rc.config.d/savecrash ] 
    then
      . /etc/rc.config.d/savecrash
      # check if SAVECRASH is set
      if [[ ! -z $SAVECRASH ]]
      then
      case ${COMPRESS} in
        0) Compress_Option="Turned off. ";;
        1) Compress_Option="Turned on. ";;
        2) Compress_Option="Don't care (default). ";;
        *) Compress_Option="N/A";;
      esac
      SAVECORE=$SAVECRASH
      SAVECORE_DIR=$SAVECRASH_DIR
      Debug "  found /etc/rc.config.d/savecrash with following parms:"
      Debug "    SAVECORE=$SAVECRASH"
      Debug "    SAVECORE_DIR=$SAVECRASH_DIR"
      Debug "    CHUNK_SIZE=$CHUNK_SIZE"
      Debug "    COMPRESS=$COMPRESS"
      Debug "    MIN_FREE=$MIN_FREE"
      Debug "    SWAP_LEVEL=$SWAP_LEVEL"
      Debug "    FOREGRD=$FOREGRD"
      Debug "    SAVE_PART=$SAVE_PART"
      Debug "    LOG_ONLY=$LOG_ONLY"
      else
      Debug "  SAVECRASH is DISABLED"
      SAVECORE=0
      fi
#
# Now check for the crashconf file. This file can be used to set additional
# dump parameters in V11.x
#
      if [ -f /etc/rc.config.d/crashconf ]
      then
        . /etc/rc.config.d/crashconf
        # check if CRASHCONF_ENABLED is set
        if [[ -z $CRASHCONF_ENABLED ]]
        then
          Debug "  CrashConf is disabled."
      else

# Changed: 12/15/98 by Greg Sterling
# If we're using V11.x, and CRASHCONF is enabled, the we've costomized the
# DUMP output. The equation below does not apply to this scenario.
# TotalMemoryDumpSize = MemoryDumpSize + KernelSizeMb + KernelSafetyFactor
#
# The actual dumpsize can not be computed from the crashconf utility. The
# kernel size and safety values can be set to zero since the crashconf utility
# already calculates these values.
#
        crashconf_dumpsize=$(/sbin/crashconf -v | grep 'Total pages included' \
               | awk '{ print $6}')
        crashconf_dumpsize=$(expr ${crashconf_dumpsize} \* 4096 / 1024 / 1024)
#       KernelSizeMB=0
#       KernelSafetyFactor=0

        Debug "  found /etc/rc.config.d/crashconf with following parms:"
        Debug "    CRASHCONF_ENABLED=$CRASHCONF_ENABLED"
        Debug "    CRASH_INCLUDED_PAGES=$CRASH_INCLUDED_PAGES"
        Debug "    CRASH_EXCLUDED_PAGES=$CRASH_EXCLUDED_PAGES"
        Debug "    CRASHCONF_READ_FSTAB=$CRASHCONF_READ_FSTAB"
        Debug "    CRASHCONF_REPLACE=$CRASHCONF_REPLACE"
#
# Check to see if the CRASHCONF_READ_FSTAB variable is set. If yes, then
# the system will check the /etc/fstab file to see if there are any additional
# dump spaces defined. If the CRASHCONF_REPLACE variable is set then all
# the definitions/parameters defined in this section will replace any
# previously defined DUMP parameters in the kernel.
#
        if [[ ! -z $CRASHCONF_READ_FSTAB ]]
        then
          Debug "  crashconf_read_fstab is enabled."
          crashconf_fstabs=$(awk ' $3=="dump" {printf("%s ",$1)}' /etc/fstab )

          Debug "  list of crashconf_fstabs = $crashconf_fstabs"
          if [[ -z $crashconf_fstabs ]]
          then
            Debug "  crashconf_fstabs list is empty. Will continue to "
            Debug "    use the lvlnboot info."
          else
            if [[ -z $CRASHCONF_REPLACE ]]
            then
              Debug "  crashconf_fstabs will be added to existing \
                         configuration."
              rootdump="$rootdump $crashconf_fstabs"
            else
              Debug "  crashconf_fstabs will replace default dump config."
              rootdump=$crashconf_fstabs
            fi
          fi
        fi
      fi
    else
      Debug "  could not find /etc/rc.config.d/crashconf"
      print "ERROR ${sysname}:/etc/rc.config.d/crashconf defaults file MISSING" >> /tmp/sysinfo.$$.errwarn
    fi
  fi
  else  
    # must be a 10.x system
    Debug "  10.x system."
    if [ -f /etc/rc.config.d/savecore ] 
    then
      . /etc/rc.config.d/savecore
      case ${COMPRESS} in
        0) Compress_Option="Turned off. ";;
        1) Compress_Option="Turned on. ";;
        2) Compress_Option="Don't care (default). ";;
        *) Compress_Option="N/A";;
      esac
      Debug "  found /etc/rc.config.d/savecore with following parms:"
      Debug "    SAVECORE=$SAVECORE"
      Debug "    SAVECORE_DIR=$SAVECORE_DIR"
      Debug "    CHUNK_SIZE=$CHUNK_SIZE"
      Debug "    COMPRESS=$COMPRESS"
      Debug "    MIN_FREE=$MIN_FREE"
      Debug "    SWAP_LEVEL=$SWAP_LEVEL"
      Debug "    FOREGRD=$FOREGRD"
    else
      Debug "  could not find /etc/rc.config.d/savecore"
      print "ERROR: ${sysname}:/etc/rc.config.d/savecore defaults file MISSING" >> /tmp/sysinfo.$$.errwarn
    fi

  fi

# Updated: Greg Sterling
# I moved this section of code outside the savesore/crashconf checks above.
# This dump calculation is pertinent to any version of HPUX and should not be
# restricted to V10.x
#
  if (($lvm_installed))
  then
    Debug "Checking for dump space"
    Debug "  rootdump = ${rootdump}"
    for logvol in ${rootdump}
    do
#
# Added by Greg Sterling
# This code checks for a preceeding /dev. if it exists then
# continue, otherwise append the /dev/vg00 to the lvol definition.
#
      echo $logvol | grep -q "^/dev/"
      if [[ $? -ne 0 ]]
      then
        Debug "  adding /dev/vg00 to lvol name"
        logvol="/dev/vg00/${logvol}"
      fi
#
# Added by Greg Sterling
# Validate the logvol is a logical volume. Its possible for dump
# devices in later versions of HPUX to be disks w/out LVM
#
        lvdisplay $logvol > /dev/null 2>&1
        if [[ $? -ne 0 ]]
        then
          Debug "    dump device is not a logical volume."
          rlogvol=$( echo $logvol | sed -e "s:^/dev/dsk/:/dev/rdsk/:" )
          DumpSize=$( diskinfo $rlogvol | grep "size" | awk '{print $2}')
          DumpSize=$( expr $DumpSize / 1024 )
        else
          DumpSize=$(lvdisplay $logvol | grep "LV Size" | awk '{print $4}')
          Debug "    $logvol DumpSize = ${DumpSize}"
        fi
        Debug "  Adding $DumpSize to DumpDiskCapacity = ${DumpDiskCapacity}"
        ((DumpDiskCapacity = DumpDiskCapacity + DumpSize))
      done
      Debug "  DumpDiskCapacity =${DumpDiskCapacity}"
    fi
    Debug "Checking how much to dump"
    # add kernel size to memory plus 2Mb safety factor
    ((TotalMemoryDumpSize = MemoryDumpSize + KernelSizeMb + KernelSafetyFactor))
    Debug "  REAL_MEM = $REAL_MEM"
    Debug "  memory =               $memory"
    Debug "  KernelSizeMb =           $KernelSizeMb"
    Debug "  KernelSafetyFactor =     $KernelSafetyFactor"
    Debug "                     ---------"
    Debug "  TotalMemoryDumpSize =  $TotalMemoryDumpSize"

    if (($BATCH))
    then
      print -n "."
    fi
# now check to see if everything is okay.
#
# Updated: 12/15/98 by Greg Sterling
# I updated this code to consider the CRASHCONF utility on V11.x. The
# TotalMemoryDumpSize parameter is only relevent for a FULL crash dump.
# Normal system crashes (if there is such a thing), can be captured within
# smaller dump spaces due to the CRASHUTIL utility.
#
    case $osmajor in
      11 )
         if (( DumpDiskCapacity < TotalMemoryDumpSize ))
         then
           if (( DumpDiskCapacity < crashconf_dumpsize ))
           then
             print "WARNING (${sysname}): Dump space is underconfigured!" \
                     >> /tmp/sysinfo.$$.errwarn
           else
             print "WARNING (${sysname}): Dump space is underconfigured \
for a FULL crashdump." >> /tmp/sysinfo.$$.errwarn
             print "WARNING (${sysname}): Dump space is adequate for the \
CRASHCONF configuration." >> /tmp/sysinfo.$$.errwarn
           fi
         fi
       ;;

 8 | 9 | 10 )
         if (( DumpDiskCapacity < TotalMemoryDumpSize ))
         then
           print "WARNING (${sysname}): Dump space is under configured!" \
                   >> /tmp/sysinfo.$$.errwarn
         fi
       ;;
  esac
  if ((! (($exit_code)) ))
  then
    exit_code=${WARN}
  fi

  if (( ! $SAVECORE ))
  then
    SAVECORE=Disabled
    if ((! (($exit_code)) ))
    then
      exit_code=${WARN}
    fi

    case $osmajor in
      8 | 9 | 10 )
       print "WARNING (${sysname}): Savecore is not enabled!" \
                 >> /tmp/sysinfo.$$.errwarn
      ;;

      11 )
       if [[ -z $CRASHCONF_ENABLED ]]
       then
        Debug "Savecore is Disabled and CrashConf is Disabled."
        print "WARNING (${sysname}):Both Savecore and crashconf are disabled!" \
                 >> /tmp/sysinfo.$$.errwarn
       fi
      ;;
    esac

  else


  # Now check if enough disk space exists to hold savecore
  Debug "Checking for sufficient savecore space"
  COMPRESSION="Not Applicable"
  if [[ -d $SAVECORE_DIR ]] 
  then
    #SaveCoreAvail=$(bdf $SAVECORE_DIR | grep /dev/ | awk '{print $4}')
    # fix for non-standard lvol names
    SaveCoreAvail=$(df -b $SAVECORE_DIR | awk '{print $5}')
    ((SaveCoreAvail = SaveCoreAvail / 1024))
    Debug "  SAVECORE=$SAVECORE"
    Debug "  SAVECORE_DIR=$SAVECORE_DIR" 
    Debug "  SaveCoreAvail=$SaveCoreAvail" 
  else
    SaveCoreAvail=0
    if ((! (($exit_code)) ))
    then
      exit_code=${WARN}
    fi
    print "WARNING (${sysname}): Directory $SAVECORE_DIR does not exist!" >> /tmp/sysinfo.$$.errwarn
  fi
    if ((($osmajor == 10))  && (($osminor >= 10))) || (( $osmajor > 10 ))
    then
      COMPRESSION="Available"
      compression_factor=${compression_factor:-50}
      ((MemoryCompression = (TotalMemoryDumpSize * $compression_factor) / 100 ))
      ((CompressedMemoryDumpSize = TotalMemoryDumpSize - MemoryCompression))

      Debug "  Checking for savecore compression"
      Debug "    Compress_option=$Compress_Option"
      Debug "    Compression=$COMPRESSION"
      Debug "    compression_factor=$compression_factor"
      Debug "    CompressedMemoryDumpSize after = $CompressedMemoryDumpSize"
      if (( $CompressedMemoryDumpSize  > $SaveCoreAvail ))
      then
        if ((! (($exit_code)) ))
        then
          exit_code=${WARN}
        fi
        print "WARNING (${sysname}): Insufficient file space to hold savecore!" >> /tmp/sysinfo.$$.errwarn
      fi
    else
      if (( $TotalMemoryDumpSize  > $SaveCoreAvail ))
      then
        if ((! (($exit_code)) ))
        then
          exit_code=${WARN}
        fi
        print "WARNING (${sysname}): Insufficient file space to hold savecore!" >> /tmp/sysinfo.$$.errwarn
      fi
    fi
    SaveCoreAvail_Out=$SaveCoreAvail
    SAVECORE=Enabled
  fi

  TotalMemoryDumpSizeOut=$TotalMemoryDumpSize

# now let's print it.
  if (($HTML))
  then
    print "</PRE>" >> /tmp/sysinfo.$$.sysout
    print "<A name='System'></A>" >> /tmp/sysinfo.$$.sysout
    print "<H2>" >> /tmp/sysinfo.$$.sysout
    print "<FONT COLOR=red>" >> /tmp/sysinfo.$$.sysout
    print "System Data" >> /tmp/sysinfo.$$.sysout
    print "</FONT></H2>" >> /tmp/sysinfo.$$.sysout
    print "<PRE><font size = '4'>" >> /tmp/sysinfo.$$.sysout
  else
    print "" >> /tmp/sysinfo.$$.sysout
    print "SYSTEM DATA" >> /tmp/sysinfo.$$.sysout
    print "===========" >> /tmp/sysinfo.$$.sysout
  fi
  print "HOSTNAME:      ${sysname}" >> /tmp/sysinfo.$$.sysout
  print "SYSTEM:        ${system}" >> /tmp/sysinfo.$$.sysout
  print "MODEL:         ${series}" >> /tmp/sysinfo.$$.sysout
  if [[ -n ${pa_chip} ]]
  then
    print "RISC CHIP:     ${pa_chip}" >> /tmp/sysinfo.$$.sysout
    print "PA VERSION:    ${pa_ver}" >> /tmp/sysinfo.$$.sysout
  fi
  if [[ -n ${serial_number} ]]
  then
    print "SERIAL #:      ${serial_number}" >> /tmp/sysinfo.$$.sysout
  fi
  print "SYSTEM ID:     ${machine_id}" >> /tmp/sysinfo.$$.sysout
  print "CPU SPEED:     ${cpu_speed} MHz" >> /tmp/sysinfo.$$.sysout
  print "CPUS:          ${processor_count} active processor(s) " >> /tmp/sysinfo.$$.sysout
  print "MEMORY:        ${memory} Mbytes of memory." >> /tmp/sysinfo.$$.sysout
  print -n "HP-UX VERSION: ${osletter}.${osmajor}.${osminor}" >> /tmp/sysinfo.$$.sysout
  if (( $osmajor == 11 ))
  then
    print "   ${k32_64} Bit" >> /tmp/sysinfo.$$.sysout
  else
    print "" >> /tmp/sysinfo.$$.sysout
  fi
  print "USER LICENSE:  ${license}" >> /tmp/sysinfo.$$.sysout
  print "LAST BOOT:     ${boot_time}" >> /tmp/sysinfo.$$.sysout
  print "LAST PATCH:    ${last_patch}\n" >> /tmp/sysinfo.$$.sysout
  print "" >> /tmp/sysinfo.$$.sysout

  if (( ${cstm_ok} == 0 ))
  then
    print "System H/W data" >> /tmp/sysinfo.$$.sysout
    print "===============" >> /tmp/sysinfo.$$.sysout
    print "  Processor data" >> /tmp/sysinfo.$$.sysout
    print -- "  --------------" >> /tmp/sysinfo.$$.sysout
    print "       H/W          PDC        Cache Size    TLB Size" >>/tmp/sysinfo.$$.sysout
    print "   path  slot    rev level    Inst   Data  Inst   Data" >>/tmp/sysinfo.$$.sysout
    print -- "  -----------------------------------------------------" >>/tmp/sysinfo.$$.sysout
    cat $cstm_cpu_out2 | awk -F: '
        {printf("%8s%6s%14s%7s%7s%6s%6s\n",$1,$2,$3,$4,$5,$6,$7)}
        ' >> /tmp/sysinfo.$$.sysout

    print "" >> /tmp/sysinfo.$$.sysout
    print    "  Memory Information" >> /tmp/sysinfo.$$.sysout
    print -- "  ------------------" >> /tmp/sysinfo.$$.sysout
    #print "    Total Physical Memory    = $cstm_tot_phys MB" \
    #         >> /tmp/sysinfo.$$.sysout
    #print "    Total Configured Memory  = $cstm_tot_conf MB" \
    #         >> /tmp/sysinfo.$$.sysout
    #print "    Memory Page Size         = $cstm_page_size Bytes" \
    #         >> /tmp/sysinfo.$$.sysout
    #print "$cstm_interleave" >> /tmp/sysinfo.$$.sysout
    #print "" >> /tmp/sysinfo.$$.sysout

    cat ${cstm_mem_out} | tail -n +10 | sed -e '/^$/d' >> /tmp/sysinfo.$$.sysout
    print "" >> /tmp/sysinfo.$$.sysout
  fi

  print "SWAP DATA" >> /tmp/sysinfo.$$.sysout
  print "=========" >> /tmp/sysinfo.$$.sysout
  if (( $osmajor >= 10 ))
  then
    Debug "`swapinfo -dtfnrMa`"
  else
    Debug "`swapinfo -dtfa`"
  fi

  swapinfo -m | grep dev | \
      awk '{printf "%6s MB on %s\n",$2,$9}' >> /tmp/sysinfo.$$.sysout
  swapinfo -m | grep fs | \
      awk '{printf "%6s MB on %s\n",$2,$9}' >> /tmp/sysinfo.$$.sysout
  swapinfo -m | grep memory | \
      awk '{printf "%6s MB on memory\n",$2}' >> /tmp/sysinfo.$$.sysout
  print -- "  ----" >> /tmp/sysinfo.$$.sysout

  if (( $osmajor >= 10 ))
  then
    swapinfo -mdfMt | grep total | \
        awk '{printf "%6s MB Total \n",$2}' >> /tmp/sysinfo.$$.sysout
  else
    swapinfo -mdft | grep tot | \
        awk '{printf "%6s MB Total \n",$2}' >> /tmp/sysinfo.$$.sysout
  fi
  print "" >> /tmp/sysinfo.$$.sysout
  print "DUMP DISKS"            >> /tmp/sysinfo.$$.sysout
  print "=========="            >> /tmp/sysinfo.$$.sysout
  lvlnboot -v /dev/vg00 2>&1 | grep Dump | awk '{print "  "$0}' >> \
               /tmp/sysinfo.$$.sysout 
  print "" >> /tmp/sysinfo.$$.sysout
  print "DUMP DATA" >> /tmp/sysinfo.$$.sysout
  print "=========" >> /tmp/sysinfo.$$.sysout
  print "SAVECORE:                  ${SAVECORE}" >> /tmp/sysinfo.$$.sysout
  case ${SAVECORE} in
    D* )
      ;;
    E* )
      print "SAVECORE DIR:              ${SAVECORE_DIR}" >> \
                   /tmp/sysinfo.$$.sysout
      if ((($osmajor == 10)) && (($osminor >= 10))) || (( $osmajor > 10 ))
      then
        print "SAVECORE COMPRESSION:      ${COMPRESSION}" >> \
                   /tmp/sysinfo.$$.sysout
        print "COMPRESSION OPTION:        ${Compress_Option}" >> \
                   /tmp/sysinfo.$$.sysout
        print "COMPRESSION FACTOR:          ${compression_factor} %" >> \
                   /tmp/sysinfo.$$.sysout
        print "COMPRESSED MEMORY TO DUMP:   ${CompressedMemoryDumpSize} MB" >> \
                   /tmp/sysinfo.$$.sysout
        print "SAVECORE CAPACITY:           ${SaveCoreAvail_Out} MB\n" >> \
                   /tmp/sysinfo.$$.sysout
      fi
      ;;
  esac
  
#
# Added: Greg Sterling
# Added code to output the status of the CrashConf configuration.
#
  if (($osmajor > 10))
  then
    if [[ ! -z $CRASHCONF_ENABLED ]]
    then
      print "" >> /tmp/sysinfo.$$.sysout
      if [[ -z $CRASHCONF_READ_FSTAB ]]
      then
        print "CRASHCONF             : Enabled" >> /tmp/sysinfo.$$.sysout
      else
        print "CRASHCONF             : Enabled (referencing /etc/fstab)" >> \
                /tmp/sysinfo.$$.sysout
      fi
      if [[ -z $CRASHCONF_REPLACE ]]
      then
        print "   Replace Option     : CrashConf values have been Added to existing Kernel Definitions." >> /tmp/sysinfo.$$.sysout
      else
        print "   Replace Option     : CrashConf values REPLACE existing Kernel Definitions." >> /tmp/sysinfo.$$.sysout
      fi

      print "   Included Pages     : $CRASH_INCLUDED_PAGES" >> \
                /tmp/sysinfo.$$.sysout
      print "   Excluded Pages     : $CRASH_EXCLUDED_PAGES" >> \
                /tmp/sysinfo.$$.sysout
      print "   FSTAB File Entries : $crashconf_fstabs" >> \
                /tmp/sysinfo.$$.sysout
      print "   CRASHCONF Configured MEMORY TO DUMP: ${crashconf_dumpsize} MB" \
                 >> /tmp/sysinfo.$$.sysout
    else
      print "CRASHCONF             : Disabled" >> /tmp/sysinfo.$$.sysout
    fi
    print "" >> /tmp/sysinfo.$$.sysout
  fi

  print "KERNEL SIZE:                ${kernel_size} Bytes." >> \
                     /tmp/sysinfo.$$.sysout
  print "TOTAL MEMORY TO DUMP:        ${TotalMemoryDumpSizeOut} MB" >> \
                     /tmp/sysinfo.$$.sysout

  print "DUMP DISK CAPACITY:          ${DumpDiskCapacity} MB" >> \
                   /tmp/sysinfo.$$.sysout

  f_display_file /tmp/sysinfo.$$.sysout 
  f_display_file /tmp/sysinfo.$$.stmout 
  #f_display_file /tmp/sysinfo.$$.dumpwarn 
  print "" >> /tmp/sysinfo.$$.sysout

#  if (($BATCH))
#  then
    print 
#  fi
}                # end of f_get_system_data

function f_call_getkinfo
{
/usr/sam/lbin/getkinfo -b -o ${sam_kinfo}
}

function get_all_parms
{
Debug "starting get_all_parms"
awk '
     BEGIN { FS = "\n"; RS = "}" }
     {print $0}
    ' $sam_kinfo | \
    awk '
         /KC_PARAM_NAME/      {name = $3;  printf("%s,", name)}
         /KC_PARAM_CLASS/     {class = $3 " " $4; printf("%s\n", class)}
        ' #| sed -e 's/\"*//g'
}

function get_all_classes
{
Debug "starting get_all_classes"
awk ' BEGIN { FS = "\n"; RS = "}" }
      $0 ~ /'\"$parm\"'/ {print $0}' $sam_kinfo \
        | awk '
          /^KC_PARAM_CLASS/     {printf("%s %s\n",$3,$4)}
          ' #| sed -e 's/\"*//g'
}

function f_query_sam
{
  sam_parm=$1
  type=$2
    awk ' BEGIN { FS = "\n"; RS = "}" }
      $0 ~ /'$sam_parm'/ {print $0}' $sam_kinfo \
          | awk '
          /^KC_PARAM_NAME/      {name = $3}
          /^KC_PARAM_STATUS/    {status = $3}
          /^KC_PARAM_DEFAULT/   {default = $3}
          /^KC_PARAM_MAX/       {max = $3}
          /^KC_PARAM_MIN/       {min = $3}
          /^KC_PARAM_CLASS/     {class = $3" " $4}
          /^KC_PARAM_DESC/      {desc = ""
                                 for(i=3;i<=NF;i++)
                                 desc = desc $i " ";
                                 }

          END { printf("%s@%s@%s@%s@%s@%s@%s\n",
                        name,status,default,max,min,desc,class)}
    ' | sed -e 's/\"*//g'

}

#===================================================================
# f_get_kernel_data
#        This function queries the kernel for various parameters.
#===================================================================
function f_get_kernel_data 
{

  Debug "Beginning KERNEL check."
  if (($BATCH))
  then
    print -n "collecting kernel data "
    print "" >> /tmp/sysinfo.$$.kernout
  else
    print    "Collecting kernel metrics....please wait."
  fi
 
  if (($HTML))
  then
    print "</PRE>" >> /tmp/sysinfo.$$.kernout
    print "<A name='Kernel'></A>" >> /tmp/sysinfo.$$.kernout
    print "<H2>" >> /tmp/sysinfo.$$.kernout
    print "<P ALIGN=RIGHT><A HREF='#Top'>TOP</A></P>" >> /tmp/sysinfo.$$.kernout
    print "<FONT COLOR=red>" >> /tmp/sysinfo.$$.kernout
    if (( ${FULL_KERNEL} ))
    then
      print "Kernel Parms (Verbose Listing)" >> /tmp/sysinfo.$$.kernout
    else
      print "Kernel Parms (Brief Listing)" >> /tmp/sysinfo.$$.kernout
    fi
    print "</FONT></H2>" >> /tmp/sysinfo.$$.kernout
    print "<PRE><font size = '4'>" >> /tmp/sysinfo.$$.kernout
  else
    print "KERNEL PARAMETERS" >> /tmp/sysinfo.$$.kernout
    print "=================" >> /tmp/sysinfo.$$.kernout
  fi

Debug "calling f_call_getkinfo -> ${sam_kinfo}"
f_call_getkinfo

Debug "calling get_all_parms -> ${all_parms_file}"
get_all_parms > ${all_parms_file}
Debug " parm names = `cat ${all_parms_file}`"

Debug "calling get_all_classes -> ${all_classes_file}"
get_all_classes | sort -t , -k 7 | uniq  > ${all_classes_file}
    #sed -e 's/ /_/g' -e 's/_$//g'  > ${all_classes_file}
Debug " class names = `cat ${all_classes_file}`"

exec 3< ${all_classes_file}
exec 4< ${all_parms_file}
while read -u3 class
do
  if (($BATCH))
  then
    print -n "."
  fi
  print_class=$(echo $class | sed -e 's/\"*//g')
  if (($HTML))
  then
    print "<H3>${print_class} Metrics</H3>" >> /tmp/sysinfo.$$.kernout
  else
    print "${print_class} Metrics" >> /tmp/sysinfo.$$.kernout
    print "============================" >> /tmp/sysinfo.$$.kernout
  fi
  Debug "Class = ${class}"
  for parm1 in $(grep "${class}" ${all_parms_file} | awk -F, '{print $1}')
  do
    Debug "Parm1 = $parm1"
    if (($FULL_KERNEL))
    then
    f_query_sam ${parm1} | \
    awk 'BEGIN {FS = "@"}
         {printf("%s\n",$1)
          printf("   Title:   %s\n",$6)
          printf("   Current: %s\n",$2)
          printf("   Default: %s\n",$3)
          printf("   Min:     %s\n",$5)
          printf("   Max:     %s\n",$4)
         #printf("   Class:   %s\n",$7)
         } '>> /tmp/sysinfo.$$.kernout
    else
    f_query_sam ${parm1} | \
    awk 'BEGIN {FS = "@"}
         {printf("  %-20s  %s\n",$1,$2)
         } ' >> /tmp/sysinfo.$$.kernout
    fi
  done
print "" >> /tmp/sysinfo.$$.kernout
done
  print "" >> /tmp/sysinfo.$$.kernout
  f_display_file /tmp/sysinfo.$$.kernout 

if (($PASS))
then 
  if (($DB_on_this_sys))
  then
    dbc_max=$(grep dbc_max /tmp/sysinfo.$$.kernout | awk '{print $2}')
    if (( dbc_max > 10 ))
    then
      print "WARNING ($sysname): dbc_max is set to ${dbc_max} on DB server" >> \
              /tmp/sysinfo.$$.sapwarn
    fi
  fi   
fi
  f_display_file /tmp/sysinfo.$$.kernwarn 
  if (($BATCH))
  then
    print ""
  fi
}                # end of f_get_kernel_data 

#===================================================================
# f_get_9x_kernel_data
#        This function queries the kernel for various parameters.
#===================================================================
function f_get_9x_kernel_data
{

  Debug "Beginning 9x KERNEL check."
  if (($BATCH))
  then
    print -n "collecting kernel data "
  fi
  shmmni=$(echo 'shmmni/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  maxfiles=$(echo 'maxfiles/D'|adb  $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  if (($BATCH))
  then
    print -n "."
  fi
  shmmax=$(echo 'shmmax/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  shmseg=$(echo 'shmseg/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  shmem=$(echo 'shmem/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  if (($BATCH))
  then
    print -n "."
  fi
  maxfiles_lim=$(echo 'maxfiles_lim/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  maxuprc=$(echo 'maxuprc/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  if (($BATCH))
  then
    print -n "."
  fi
  nproc=$(echo 'nproc/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  nfile=$(echo 'nfile/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  if (($BATCH))
  then
    print -n "."
  fi
  nflocks=$(echo 'nflocks/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  ninode=$(echo 'ninode/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  if (($BATCH))
  then
    print -n "."
  fi
# PA8000 chips support variable page sizes
  super_page_supp=$(echo cpu_has_var_size_pages/D | adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  case $super_page_supp in
      0)  super_page_support=no;;
      1)  super_page_support=yes;;
      *)  super_page_support=n/a;;  # not found in kernel
  esac
  if (($BATCH))
  then
    print -n "."
  fi
  npty=$(echo 'npty/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
# check for asynch disc writes enabled
  fs_async=$(echo 'fs_async/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  if ((${fs_async} == 0))
  then
    fs_async=no
  else
    fs_async=yes
  fi
  if (($BATCH))
  then
    print -n "."
  fi
  nbuf=$(echo 'nbuf/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  bufpages=$(echo 'bufpages/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')

  if (($BATCH))
  then
    print -n "."
  fi
  msgmap=$(echo 'msgmap/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  if (($BATCH))
  then
    print -n "."
  fi
  maxdsiz=$(echo 'maxdsiz/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  maxssiz=$(echo 'maxssiz/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  if (($BATCH))
  then
    print -n "."
  fi
  maxtsiz=$(echo 'maxtsiz/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  maxuprc=$(echo 'maxuprc/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  if (($BATCH))
  then
    print -n "."
  fi
  ncdnode=$(echo 'ncdnode/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  if (($BATCH))
  then
    print -n "."
  fi
  sema=$(echo 'sema/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  if (($BATCH))
  then
    print -n "."
  fi
  semmap=$(echo 'semmap/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  if (($BATCH))
  then
    print -n "."
  fi
# get LVM related kernel parameters
  maxvgs=$(echo 'maxvgs/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  lv_vgs_opn=$(echo 'lv_vgs_opn/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  if (($BATCH))
  then
    print -n "."
  fi
  lv_lvs_opn=$(echo 'lv_lvs_opn/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  lv_pbuf_cnt=$(echo 'lv_pbuf_cnt/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  if (($BATCH))
  then
    print -n "."
  fi
  lv_pbuf_inuse=$(echo 'lv_pbuf_inuse/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  lv_pbuf_maxuse=$(echo 'lv_pbuf_maxuse/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')
  if (($BATCH))
  then
    print -n "."
  fi
  lv_pbuf_pending_Q=$(echo 'lv_pbuf_pending_Q/D'|adb $kernel /dev/kmem \
           | tail -1 | awk '{print $2}')

  if (($HTML))
  then
    print "</PRE>" >> /tmp/sysinfo.$$.kernout
    print "<A name='Kernel'></A>" >> /tmp/sysinfo.$$.kernout
    print "<FONT COLOR=red>" >> /tmp/sysinfo.$$.kernout
    print "<H2>Kernel Data</H2></FONT>" >> /tmp/sysinfo.$$.kernout
    print "<PRE><font size = '4'>" >> /tmp/sysinfo.$$.kernout
  else
    print "KERNEL DATA" >> /tmp/sysinfo.$$.kernout
    print "===========" >> /tmp/sysinfo.$$.kernout
  fi
  print "Super page support (cpu_has_var_size_pages) $super_page_support" >> /tmp/sysinfo.$$.kernout
  print "" >> /tmp/sysinfo.$$.kernout
  print "Max shared memory segments in system (shmmni)$shmmni" >> /tmp/sysinfo.$$.kernout
  print "Enable Sys V Shared Memory(shmem)            ${shmem}" >> /tmp/sysinfo.$$.kernout

  print "" >> /tmp/sysinfo.$$.kernout
  print "Soft file limit per process (maxfiles)       $maxfiles" >> /tmp/sysinfo.$$.kernout
  print "Hard file limit per process (maxfiles_lim)   $maxfiles_lim" >> /tmp/sysinfo.$$.kernout
  print "Max number of processes (nproc)              $nproc" >> /tmp/sysinfo.$$.kernout
  print "Max number of user processes (maxuprc)       $maxuprc" >> /tmp/sysinfo.$$.kernout
  print "Number of open files in system (nfile)       $nfile" >> /tmp/sysinfo.$$.kernout
  print "Maximum number of file locks (nflocks)       $nflocks" >> /tmp/sysinfo.$$.kernout
  print "Max number of in-core inodes (ninode)        $ninode" >> /tmp/sysinfo.$$.kernout
  print "Asynchronous disk writes allowed (fs_async)  $fs_async" >> /tmp/sysinfo.$$.kernout
  print "Number of pseudo-teletypes (npty)            $npty" >> /tmp/sysinfo.$$.kernout
  print "Number of filesystem buffer headers (nbuf)   $nbuf" >> /tmp/sysinfo.$$.kernout
  print "Number of buffer pages in cache (bufpages)   $bufpages" >> /tmp/sysinfo.$$.kernout
  print "Max Number of Message Map Entries (msgmap)   $msgmap" >> /tmp/sysinfo.$$.kernout
  print "Max Data Segment Size (Bytes) (maxdsiz)      $maxdsiz" >> /tmp/sysinfo.$$.kernout
  print "Max Stack Segment Size (Bytes) (maxssiz)     $maxssiz" >> /tmp/sysinfo.$$.kernout
  print "Max Text Segment Size (Bytes) (maxtsiz)      $maxtsiz" >> /tmp/sysinfo.$$.kernout
  print "Enable Sys V Semaphores (sema)               $sema" >> /tmp/sysinfo.$$.kernout

  if (($lvm_installed))
  then
    print "" >> /tmp/sysinfo.$$.kernout
    print "LVM Parms" >> /tmp/sysinfo.$$.kernout
    print "  Max number of volume groups (maxvgs)       $maxvgs" >> /tmp/sysinfo.$$.kernout
    print "  Number of open volume groups (lv_vgs_opn)  $lv_vgs_opn" >> /tmp/sysinfo.$$.kernout
    print "  Number of open logical volumes (lv_lvs_opn)$lv_lvs_opn" >> /tmp/sysinfo.$$.kernout
    print "  Lvol pbuf count (lv_pbuf_cnt)              $lv_pbuf_cnt" >> /tmp/sysinfo.$$.kernout
    print "  Lvol pbuf current usage (lv_pbuf_inuse)    $lv_pbuf_inuse" >> /tmp/sysinfo.$$.kernout
    print "  Lvol pbuf high water mark (lv_pbuf_maxuse) $lv_pbuf_maxuse" >> /tmp/sysinfo.$$.kernout
    print "  lv_pbuf_pending_Q:                         $lv_pbuf_pending_Q \n" >> /tmp/sysinfo.$$.kernout
  fi
  f_display_file /tmp/sysinfo.$$.kernout
  f_display_file /tmp/sysinfo.$$.kernwarn
  if (($BATCH))
  then
    print ""
  fi
}                # end of f_get_9x_kernel_data


#===================================================================
# f_get_network_data
#        This function queries each lan card and retrieves information
#        for each one.
#===================================================================
function f_get_network_data
{
  Debug "Beginning NETWORK check."
  if (($BATCH))
  then
    print -n "scanning network cards "
  fi
  GetCurrentDNS
  #DOMAIN=$(nslookup ${sysname} | grep Name | grep -v Server | cut -d. -f2-6)
  default_router=$( netstat -r | grep default | awk '{print $2}')
  default_router_ip=$( netstat -rn | grep default | awk '{print $2}')
  if (($HTML))
  then
    print "</PRE>"                 >> /tmp/sysinfo.$$.netout
    print "<A NAME='Network'></A>" >> /tmp/sysinfo.$$.netout
    print "<H2>" >> /tmp/sysinfo.$$.netout
    print "<P ALIGN=RIGHT><A HREF='#Top'>TOP</A></P>" >> /tmp/sysinfo.$$.netout
    print "<FONT COLOR=red>" >> /tmp/sysinfo.$$.netout
    print "Network Data </H2>" >> /tmp/sysinfo.$$.netout
    print "</FONT><PRE><font size = '4'>" >> /tmp/sysinfo.$$.netout
  else
    print "NETWORK DATA" >> /tmp/sysinfo.$$.netout
    print "============" >> /tmp/sysinfo.$$.netout
  fi
  print "DOMAIN NAME:    ${CURRENT_DOMAIN}" >> /tmp/sysinfo.$$.netout
  print -n "DNS SERVER:     ${CURRENT_DNS_SERVER}  " >> /tmp/sysinfo.$$.netout
  print "(${CURRENT_DNS_SERVER_IP})" >> /tmp/sysinfo.$$.netout
  print -n "DEFAULT ROUTER: ${default_router}  "  >> /tmp/sysinfo.$$.netout
  print "(${default_router_ip})"  >> /tmp/sysinfo.$$.netout
  print "" >> /tmp/sysinfo.$$.netout

  #for CARD in $(netstat -in | grep lan | awk '{print $1}' | sed 's/\*//')
  # 1.42 change to handle multiple I/F cards
  if (( ${osmajor} >= 10 ))
  then
    card_list=$(/etc/lanscan -i | awk '{print $1}')
    Debug " 10.x using lanscan -i"
  else
    card_list=$(/etc/lanscan | tail +3 | awk '{printf("%s\n",$5)}')
    Debug " 9.x using lanscan "
  fi
  for CARD in ${card_list}
  do
    ifconfig "${CARD}" > /tmp/sysinfo.$$.ipdata 2>&1
    if [ $? -eq 0 ]
    then
      Debug " checking lan card -> $CARD"
      #lanconfig "$CARD" >> /tmp/sysinfo.$$.ipdata 2>&1
      #card_type=$(lanconfig "$CARD" | grep ${CARD} | awk '{print $2}')
      if (( ${osmajor} >= 11 ))
      then
        card_type=$(lanscan -im  | grep "${CARD} " | awk '{print $NF}')
      else
        card_type=$(lanscan | grep "${CARD} " | awk '{print $8}')
      fi
      Debug "  card_type=$card_type"
      #MWR fix for incorrect handling of multiple lan cards
      #macaddr=$(/etc/lanscan | grep x | awk '{print $2}')
      macaddr=$(/etc/lanscan | grep "${CARD} " | awk '{print $2}')
      lan_hw_addr=$(/etc/lanscan | grep "${CARD} " | awk '{print $1}')
      nmid=$(/etc/lanscan | grep "${CARD} " | awk '{print $7}')
      ip_addr=$(grep inet /tmp/sysinfo.$$.ipdata | awk '{print $2}')
      ip_addr_name=$(LookupName ${ip_addr})
      lanspeed=$(lanadmin -s ${nmid} | awk '{print $3}')
      netmask=$(grep inet /tmp/sysinfo.$$.ipdata | awk '{print $4}')

      #convert hex netmask to decimal-dot.
      typeset -Z8  hex=0${netmask#0x}; typeset +Z hex
      typeset -L2  ott=
      typeset -i10 dec=
      netmask=""
      while [ "$hex" ]; do
        ott=$hex
        dec=16#$ott
        netmask=$netmask.$dec
        hex=${hex#??}
      done
      netmask=${netmask#.}

      broadcast=$(grep inet /tmp/sysinfo.$$.ipdata | awk '{print $6}')
      if (($HTML))
      then
        print "</PRE>" >> /tmp/sysinfo.$$.netout
        print "<H3>INTERFACE DATA for ${CARD}</H3>" >> /tmp/sysinfo.$$.netout
        print "<PRE><font size = '4'>" >> /tmp/sysinfo.$$.netout
      else
        print "INTERFACE DATA for ${CARD}" >> /tmp/sysinfo.$$.netout
        print "===========================" >> /tmp/sysinfo.$$.netout
      fi
      #print "NMID:        ${nmid}" >> /tmp/sysinfo.$$.netout
      print "H/W ADDR:    ${lan_hw_addr}" >> /tmp/sysinfo.$$.netout
      print "CARD TYPE:   ${card_type}" >> /tmp/sysinfo.$$.netout
      print "SPEED:       ${lanspeed}" >> /tmp/sysinfo.$$.netout
      print "MAC ADDRESS: ${macaddr}" >> /tmp/sysinfo.$$.netout
      print -n "IP ADDRESS:  ${ip_addr}" >> /tmp/sysinfo.$$.netout
      print "   (${ip_addr_name})" >> /tmp/sysinfo.$$.netout
      print "BROADCAST:   ${broadcast}" >> /tmp/sysinfo.$$.netout
      print "NETMASK:     ${netmask}\n" >> /tmp/sysinfo.$$.netout
    fi
    if (($BATCH))
    then
      print -n "."
    fi
  done
  f_display_file /tmp/sysinfo.$$.netout 
  if (($BATCH))
  then
    print
  fi
}                # end of f_get_network_data

function query_EMC_disks
{
Debug "Beginning query_EMC_disks"
if [ -f ${where}/inq.hp ]
then
  Debug "  found inq.hp"
  #inq.hp  
else
  Debug "  Could not find inq.hp....no query done."
fi

}
rawDiskFilter () {
    # Filters out the first raw disk file after an HP Claimed disk
        awk '
        ( $0 ~ "CLAIMED" )              { hit=0 }
        ( $0 ~ "CLAIMED" && $0 ~ "HP")  { hit=1; next }
        ( $0 !~ "CLAIMED" && hit==1)    { hit=0; print $2 }
        '
} # rawDiskFilter()


#===================================================================
# f_get_physical_disk_data
#        This function scans each physical disk.
#        It uses ioscan to collect disk info and the queries each
#        device using diskinfo. 
#        The output is displayed in sorted order.
#===================================================================
function f_get_physical_disk_data
{
  Debug "Beginning PHYSICAL DISK check."
# first let's print header information
  if (($HTML))
  then
    print "</PRE>"                             >> /tmp/sysinfo.$$.physinfoh
    print "<A NAME='Physical'></A>"            >> /tmp/sysinfo.$$.physinfoh
    print "<H2>"                               >> /tmp/sysinfo.$$.physinfoh
    print "<P ALIGN=RIGHT><A HREF='#Top'>TOP</A></P>" >> /tmp/sysinfo.$$.physinfoh
    print "<FONT COLOR=red>"                   >> /tmp/sysinfo.$$.physinfoh
    print "Physical Disk Data </H2>"           >> /tmp/sysinfo.$$.physinfoh
    print "</FONT><PRE>"                       >> /tmp/sysinfo.$$.physinfoh
    print "</PRE>"                                >> /tmp/sysinfo.$$.boot
    print "<H3>Bootable Disks</H3>"               >> /tmp/sysinfo.$$.boot
    print "<PRE><font size = '3'>"                >> /tmp/sysinfo.$$.boot
    print    "Volume Name                 H/W Path    Auto Boot String" >> \
              /tmp/sysinfo.$$.boot
    print -- "--------------            ------------  ----------------" >> \
              /tmp/sysinfo.$$.boot
    print "<font size = '4'>"                     >> /tmp/sysinfo.$$.boot
  else
    print    "PHYSICAL DISK DATA" >> /tmp/sysinfo.$$.physinfoh
    print    "==================" >> /tmp/sysinfo.$$.physinfoh
    print    "BOOTABLE DISKS" >> /tmp/sysinfo.$$.boot
    print    "==============" >> /tmp/sysinfo.$$.boot
    print    "Volume Name                    H/W Path    Auto Boot String" >> \
              /tmp/sysinfo.$$.boot
    print -- "--------------               ------------  ----------------" >> \
              /tmp/sysinfo.$$.boot
  fi

 # Header for XP256 Information
  print > /tmp/sysinfo.$$.256header
  print "XP256 Disc Array Information" >> /tmp/sysinfo.$$.256header
  print "============================" >> /tmp/sysinfo.$$.256header
  print -n "                                      " >> /tmp/sysinfo.$$.256header
  print "                                    Size" >> /tmp/sysinfo.$$.256header
  print -n "Device File            Port  Scsi  Lun CU:Ldev Serial#" \
                                   >> /tmp/sysinfo.$$.256header
  print "           Type     (MB)" >> /tmp/sysinfo.$$.256header

 # Header for NIKE Array Information
  print > /tmp/sysinfo.$$.arrayheader
  print "Disk Array Information" >> /tmp/sysinfo.$$.arrayheader
  print "======================" >> /tmp/sysinfo.$$.arrayheader
  
  if (($PMAP))
  then
    if (($HTML))
    then
      print "</PRE>"                            >> /tmp/sysinfo.$$.pmap
      print "<A NAME='Pmap'></A>"               >> /tmp/sysinfo.$$.pmap
      print "<H2>"                               >> /tmp/sysinfo.$$.pmap
      print "<P ALIGN=RIGHT><A HREF='#Top'>TOP</A></P>" >> /tmp/sysinfo.$$.pmap
      print "<FONT COLOR=red>" >> /tmp/sysinfo.$$.pmap
      print "Physical Disk To Logical Volume Mapping</H2>" >> /tmp/sysinfo.$$.pmap
      print "</FONT><PRE><font size = '4'>"        >> /tmp/sysinfo.$$.pmap
    else
      print    "PHYSICAL DISK TO LOGICAL VOLUME MAPPING" >> /tmp/sysinfo.$$.pmap
      print    "=======================================" >> /tmp/sysinfo.$$.pmap
    fi
    print -n "Physical Disk                           " >> /tmp/sysinfo.$$.pmap
    print    "     Alternate Link" >> /tmp/sysinfo.$$.pmap
    print    "       Logical Volume     LE        PE" >> /tmp/sysinfo.$$.pmap
    print -n -- "----------------------------------------" >> /tmp/sysinfo.$$.pmap
    print --    "-----------------------" >> /tmp/sysinfo.$$.pmap
  fi
  Debug "  calling check_if_scan_done"
  check_if_scan_done io_scan
  print -n "scanning physical disks "

#get physical disk names
  if (( $osmajor >= 10 ))
  then
    Debug "Found 10.x system"
#   hw_path=$(ioscan -kfC disk | sed '1,/^=/d' | awk '{print $3}')
    hw_path=$(grep disk $io_scan_out | awk -F: '{print $11}' | sort)
    Debug "hw_path=$hw_path"
    for hwpath in ${hw_path}
    do
      Debug "hwpath=${hwpath}"
      lu=""
      vendor=""
      tmpin=$(echo $hwpath | cut -d. -f1)
### Changed 6/15/99 J.Semroc - to improve Performance reuse existing data
###   inst=$(ioscan -kf | grep "^ext_bus" | grep " ${tmpin} " \
###               | grep -v fcpdev | awk '{print $2}')
      inst=$(grep $hwpath $io_scan_out | grep disk | awk '{print $NF}' \
                 | cut -d: -f2)
### end of Change
      #scsi_addr=$(echo $hwpath | cut -d. -f2)
      #unit_addr=$(echo $hwpath | cut -d. -f3)
      #physvol="/dev/dsk/c${inst}t${scsi_addr}d${unit_addr}"
      #rphysvol="/dev/rdsk/c${inst}t${scsi_addr}d${unit_addr}"
      #physvol=$(ioscan -kfnH ${hwpath} | awk ' BEGIN {FS=" "; RS=" "} /dev\/dsk/ {printf("%s", $1)}')
      #rphysvol=$(ioscan -kfnH ${hwpath} | awk ' BEGIN {FS=" "; RS=" "} /dev\/rdsk/ {printf("%s", $1)}')
      #block_major=$(grep "$hwpath" $io_scan_out | grep disk | awk -F: '{print $6}')
      #char_major=$(grep "$hwpath" $io_scan_out | grep disk | awk -F: '{print $7}')
      #block_minor=$(grep "$hwpath" $io_scan_out | grep disk | awk -F: '{print $8}')
      #Debug "  block_major = ${block_major}"
      #Debug "  char_major  = ${char_major}"
      #Debug "  block_minor = ${block_minor}"

      scsi_addr=$(echo $hwpath | awk -F. '{print $(NF-1)}')
      unit_addr=$(echo $hwpath | awk -F. '{print $NF}')
      physvol="/dev/dsk/c${inst}t${scsi_addr}d${unit_addr}"
      rphysvol="/dev/rdsk/c${inst}t${scsi_addr}d${unit_addr}"

      Debug "Physical volume ${physvol}"
      Debug "  tmpin=${tmpin}"
      Debug "  inst=${inst} scsi_addr=${scsi_addr} unit_addr=${unit_addr}"

      XP256=$(grep ${hwpath} ${io_scan_out} | weed_targets | awk -F: '{print $18}')
      if [[ ${XP256} = *OPEN* ]] 
      then
        print -n "X"
        if [[ -f /usr/contrib/bin/inquiry256 ]]
        then 
          inqcmd="/usr/contrib/bin/inquiry256"
        else
          inqcmd="${where}/inquiry256"
        fi
        Debug "XP256 disc array found! ${XP256} ${hwpath}"
        Debug "inqcmd=${inqcmd}"
        info=$(diskinfo -v ${rphysvol}  2>&1)
        case "$info" in
          *"No such file or directory"* )
            Debug "  diskinfo reports No such file or directory on $physvol"
            #echo "$Inq" | \
            #   awk -F"+" '{printf("%55s\n"),$1}' \
            #      >> /tmp/sysinfo.$$.inq256
            rphysvold=$rphysvol
            print "$rphysvold   No such file or directory" \
                  >> /tmp/sysinfo.$$.inq256
          ;;
          *"No such device or address"* )
            Debug "  diskinfo reports No such device or address on $physvol"
           #echo "$Inq" | \
           #   awk -F"+" '{printf("%55s\n"),$1}' \
           #      >> /tmp/sysinfo.$$.inq256
            rphysvold=$rphysvol
            print "$rphysvold   No such device or address" \
                  >> /tmp/sysinfo.$$.inq256
          ;;
          * )
          Debug "  found a device (no diskinfo error)...so follow it"
          Inq=$(${inqcmd} ${rphysvol} 2>&1 )
          psize=$(echo $info | sed -e 's/^.*size: //' -e 's/ .*$//')
          psize_mb=$(expr ${psize} / 1024)
          product1=$(echo $info | sed -e 's/^.*product id: //' -e 's/ .*$//')
          echo "$Inq+$product1+$psize_mb" | \
             awk -F"+" '{printf("%55s%16s%8s\n"),$1,$2,$3}' \
                >> /tmp/sysinfo.$$.inq256
        esac
      fi  # end of XP256

      case ${XP256} in

        *C1300* | *C2300* | *C3400* )
          Debug " found an Nike disk array at $hwpath"
          print -n "N" 
          #f_get_array_data
        ;;
        *C2430* )
          Debug " found a Cascade disk array at $hwpath"
          print -n "C" 
          #f_get_array_data
        ;;
        *C5447A* | *C3586A* )
          # C5447A is 12H   C3586A is 12
          Debug " found a AutoRaid disk array at $hwpath"
          print -n "A" 
          #f_get_array_data
        ;;
        *A5277A* )
          Debug " found a FC60 disk array at $hwpath"
          print -n "F" 
          #f_get_array_data
        ;;
        * )
          Debug " found a jbod disk at $hwpath"
          print -n "." 
          #f_get_array_data
        ;;
      esac


# Run pvdisplay to get the disk information
      pvdisplay -v ${physvol} > /tmp/sysinfo.$$.pvdisp 2>&1
# Check for alternate link so that we don't try to access it
      Debug "  Checking if this is an alternate link"
      grep "Using Primary Link" /tmp/sysinfo.$$.pvdisp > /dev/null 2>&1
      detect_alt_link=$?
      if ((detect_alt_link == 0))
      then
        Debug "  this IS an alternate link, so skip"
        alt_link=true
      elif [[ "${rphysvol}" = "" ]] then
        Debug "  no physvol found for $hwpath"
        if ((! (($exit_code)) ))
        then
          exit_code=${WARN}
        fi
        print "WARNING (${sysname}):No device file found for $hwpath" >> \
                     /tmp/sysinfo.$$.errwarn
      else
        Debug "  this is NOT an alternate link, so query disk"
        hwpathd=${hwpath} # for display purposes
        #info=$(diskinfo -v /dev/rdsk/c${inst}t${scsi_addr}d${unit_addr} 2>&1)
        info=$(diskinfo -v ${rphysvol}  2>&1)
        Debug "info= ${info}"
        case "$info" in
          *"Device busy"* )
            Debug "  diskinfo reports Device Busy Error on $rphysvol"
            lu=$(grep ${hwpath} $io_scan_out | grep -v target \
                  | awk '{print $2}')
            vendor1=$(ioscan -H $hwpath | tail -1 | awk '{print $3}')
            vendor=${vendor1}
            product1=$(ioscan -H $hwpath | tail -1 | awk '{print $NF}')
            product=${product1}
            print "${physvol}${lu}${hwpathd} ${vendor}${product}" \
                   >> /tmp/sysinfo.$$.physinfo
            Debug "  ${physvol}${lu}${hwpathd}${vendor}${product}" 
          ;;
          *"No such file or directory"* )
            Debug "  diskinfo reports No such file or directory on $physvol"
            lu="n/f"
            vendor1=$(ioscan -H $hwpath | tail -1 | awk '{print $3}')
            vendor=${vendor1}
            product1=$(ioscan -H $hwpath | tail -1 | awk '{print $NF}')
            product=${product1}
            print "${physvol}${lu}${hwpathd} ${vendor}${product}" \
                     >> /tmp/sysinfo.$$.physinfo
          ;;
          *"No such device or address"* )
            Debug "  diskinfo reports No such device or address on $physvol"
            lu="n/f"
            vendor1=$(ioscan -H $hwpath | tail -1 | awk '{print $3}')
            vendor=${vendor1}
            product1=$(ioscan -H $hwpath | tail -1 | awk '{print $NF}')
            product=${product1}
            print "${physvol}${lu}${hwpathd} ${vendor}${product}" \
                     >> /tmp/sysinfo.$$.physinfo
          ;;
          * )
            Debug "  found a device (no diskinfo error)...so follow it"
        
          #lu=$(grep ${hwpath} $io_scan_out | grep -v target | awk '{print $2}')
### Changed 6/15/99 J.Semroc - to improve Performance reuse existing data
###       lu=$(ioscan -kfCdisk | grep "${hwpath}" | awk '{print $2}')
          lu=$(grep ${hwpath} $io_scan_out | grep -v target | grep disk | \
               awk -F: '{print $13}')
### end of Change
          Debug "LU = ${lu}"
          ludebug=$(grep ${hwpath} $io_scan_out | grep -v target )
          Debug "ludebug= ${ludebug}"
          psize=$(echo $info | sed -e 's/^.*size: //' -e 's/ .*$//')
          psize_mb=$(expr ${psize} / 1024)
          product1=$(echo $info | sed -e 's/^.*product id: //' -e 's/ .*$//')
  
          vendor1=$(echo $info | sed -e 's/^.*vendor: //' -e 's/ .*$//')
          vendor=${vendor1}
          rev_level=$(echo $info | sed -e 's/^.*rev level: //' -e 's/ .*$//')
          #rev_level=$(echo $info | grep "rev level" \
          #       | awk '{print $3}')
          product=${product1}
          if [[ "${product1}" != "CD-ROM" ]] && [[ "${product1}" != "DVD-ROM" ]]
          then
            ((total_p_mb=total_p_mb + psize_mb))
            ((pcount=pcount + 1))
          fi
          Debug "    vendor1=$vendor1"
          Debug "    product=$product"
          Debug "    rev_level=$rev_level"
          Debug "    psize=$psize"
          Debug "    psize_mb=$psize_mb"
#
# check for bootable disk
#
          Debug "  Checking for Bootable PV"
          lifls ${physvol} 2> /dev/null | grep -i isl > /dev/null 2>&1
          if [ $? -eq 0 ]
          then   
            Debug "    Found Bootable PV at ${physvol}"
            bootable_pv="Y"
            lifls ${rphysvol} | grep AUTO > /dev/null 2>&1
            if [ $? -eq 0 ]
            then   
              Debug "    Found auto_string=$auto_string"
              auto_string=$(lifcp ${rphysvol}:AUTO -)
              print "${physvol}${hwpathd}   ${auto_string}" >> \
                       /tmp/sysinfo.$$.boot
            else
              Debug "    Did not find auto_string."
            fi
          else 
            Debug "    Did not find Bootable PV on ${physvol}"
            bootable_pv="N"
          fi
          if grep "find the volume group" /tmp/sysinfo.$$.pvdisp > /dev/null
          then
            Debug "  NON-LVM   /dev/dsk/c${inst}t${scsi_addr}d${unit_addr}" 
            Debug "    id as::${vendor}${product}${psize_mb} Mbytes." 
            #lu="nlv"
          elif grep "path does not correspond" /tmp/sysinfo.$$.pvdisp > /dev/null
          then
            Debug "Specified path not found! ${rphysvol}"
          else            
            Debug "  LVM disk"
### Changed 6/15/99 J.Semroc - to improve Performance reuse existing data
###         lu=$(ioscan -kfCdisk | grep " ${hwpath}" | awk '{print $2}')
            lu=$(grep ${hwpath} $io_scan_out | grep -v target | grep disk | \
                 awk -F: '{print $13}')
### end of Change
            if [[ "${vendor1}" = "EMC" ]]  # && ((detect_alt_link == 0))
            then
              EMC_found=1
### Correction 6/15/99  J.Semroc - physvol was misspelled
              Debug " Found EMC  at ${physvol}."
              Debug "   detect_alt_link = ${detect_alt_link}"
              bblvols=$(pvdisplay -v ${physvol} |  \
                      awk ' /current/ {print $3}' | sort | uniq | \
                      grep -v "/dsk/")
              for bblvol in $bblvols
              do
                bblock=$(lvdisplay $bblvol | awk ' /Bad block/ {print $3}')
                Debug "    bblvol=  $bblvol"
                Debug "    bblock=  $bblock"
                if [[ "${bblock}" != "NONE" ]]
                then
                  if ((! (($exit_code)) ))
                  then
                    exit_code=${WARN}
                  fi
                  print "WARNING (${sysname}):EMC w/ LVM bad block enabled on ${bblvol}" >> /tmp/sysinfo.$$.errwarn
                fi
              done
            fi
            if (($PMAP)) 
            then
              Debug "  Begin PHYSICAL TO LOGICAL Mapping"
              alt_link=""
              if  (($osmajor == 11))
              then
                # PVdisplay looks different on 10.20 (MWR)
                alt_link=$(grep "^PV Name" /tmp/sysinfo.$$.pvdisp | \
                   grep "Alternate Link" | awk '{printf "%s ", $3}' )
                Debug "  =11     alt_link=$alt_link"
              elif (($osmajor == 10)) && (($osminor >= 20))
              then
                # PVdisplay looks different on 10.20 (MWR)
                alt_link=$(grep "^PV Name" /tmp/sysinfo.$$.pvdisp | \
                   grep "Alternate Link" | awk '{printf "%s ", $3}' )
                Debug "  >=10.20     alt_link=$alt_link"
              else 
                #less than 10.20
                alt_link=$(grep "^   PV Name" /tmp/sysinfo.$$.pvdisp | \
                   grep "Alternate Link" | awk '{printf "%s ", $3}' )
                Debug "  <10.20   alt_link=$alt_link"
              fi
              if  [ "$alt_link" = "" ]
              then
                alt_link="None"
              fi
              Debug "    alt_link=$alt_link"
              print "${physvol}                           ${alt_link}" \
                 >> /tmp/sysinfo.$$.pmap
              sed '1,15d;/current/d;/Status/d;/free/d;' \
                /tmp/sysinfo.$$.pvdisp | \
                sed '/^$/d;/---/d;/LV/d; s/\/dev/    \/dev/' \
                >> /tmp/sysinfo.$$.pmap
            fi   # end of PMAP
          fi
          print -n "${physvol}${lu}${hwpathd} ${vendor}${product}" >> \
                      /tmp/sysinfo.$$.physinfo
          print " ${psize_mb} ${bootable_pv}" >> \
                      /tmp/sysinfo.$$.physinfo
          ;;
        esac
        #print -n "."
      fi
    done # end of hwpath loop
    # end of 10.x system
  else      
    Debug "must be a 9.x system"
    pvol=$(vgdisplay -v 2>&1 | grep "^   PV Name" | grep -v "Alternate Link" \
           | sort | awk '{printf "%s ", $3}' )
    ioscan -kfCdisk | sort > /tmp/sysinfo.$$.io_disk
    #now force access to disks.
    for physvol in ${pvol}                        # loop through all phys vols
    do
      hwpath=$(lssf ${physvol} | awk '{printf "%s ", $(NF -1)}')
      hwpathd=${hwpath} # for display purposes
      disktype=$(echo ${physvol} | sed s/dsk/rdsk/)
      diskinfo -v ${disktype} > /tmp/sysinfo.$$.diskinfo 2>&1
      if (($?))
      then
        print "ERROR:${sysname}: diskinfo reports an error on ${physvol}."
        >> /tmp/sysinfo.$$.errwarn
        exit_code=${SYS_ERROR}
      else
        vendor=$(grep "vendor" /tmp/sysinfo.$$.diskinfo \
                 | awk '{printf "%s ", $2}')
        product1=$(grep "product id" /tmp/sysinfo.$$.diskinfo \
                 | awk '{printf "%s ", $3}')
        type=$(grep "type" /tmp/sysinfo.$$.diskinfo \
                 | cut -b22- )
        psize=$(grep "size" /tmp/sysinfo.$$.diskinfo \
                 | awk '{printf "%s ", $2}')
        psize_mb=$(expr ${psize} / 1024)
        lu=$(grep " ${hwpath}" /tmp/sysinfo.$$.io_disk | awk '{print $2}')
        rev_level=$(grep "rev level" /tmp/sysinfo.$$.diskinfo \
                 | awk '{print $3}')
        product=${product1}
        if [[ "${product1}" != "CD-ROM" ]] && [[ "${product1}" != "DVD-ROM" ]]
        then
          ((total_p_mb=total_p_mb + psize_mb))
          ((pcount=pcount + 1))
        fi
        if (($PMAP))
        then
          pvdisplay -v ${physvol} > /tmp/sysinfo.$$.pvdisp 2>&1
          alt_link=""
          alt_link=$(grep "^   PV Name" /tmp/sysinfo.$$.pvdisp | \
               grep "Alternate Link" | awk '{printf "%s ", $3}' )
          #alt_link="/dev/dsk/cxtxdx"
          if  [ "$alt_link" = "" ]
          then
            alt_link="None"
          fi
          print "${physvol}                           ${alt_link}" \
             >> /tmp/sysinfo.$$.pmap
          sed '1,15d;/current/d;/Status/d;/free/d;' /tmp/sysinfo.$$.pvdisp | \
            sed '/^$/d;/---/d;/LV/d; s/\/dev/    \/dev/' \
            >> /tmp/sysinfo.$$.pmap
        fi
        Debug "\ndisktype=$disktype"
        Debug "hwpath=$hwpath"
        Debug "vendor=$vendor"
        Debug "product=$product"
        Debug "psize=$psize"
        Debug "psize_mb=$psize_mb"
        Debug "lu=$lu"
        Debug "type=$type"
        Debug "total_p_mb=$total_p_mb"
        Debug "pcount=$pcount"
        Debug "rev_level=$rev_level"
        Debug "alt_link=$alt_link"
        print -n "."
        print "${physvol}${lu}${hwpathd}${vendor}${product}${psize_mb}" >> /tmp/sysinfo.$$.physinfo
      fi
    done
  fi # end of 9.x

  print "                             Rev" > /tmp/sysinfo.$$.disk_rev
  print "             HW Path        Level         Serial Number      LUN" \
          >> /tmp/sysinfo.$$.disk_rev
  print "   ---------------------    -----    ---------------------   ----" \
          >> /tmp/sysinfo.$$.disk_rev
  
  if (( ${cstm_ok} == 0 ))
  then
  awk '
    /Hardware path/ {path = $3; next;}
    /Product Id/   {prod = $3; vend = $NF; next;}
    /Firmware Rev/ {fw = $NF; next;}
    /Logical Unit/ {lu = $NF; next;}
    /Serial Number/ {sn = $3; next;}
    /Capacity/ {cap = $NF; printf("%24s %8s %24s %6s\n",
       path,fw,sn,lu);}' $cstm_disk_out >> /tmp/sysinfo.$$.disk_rev
  print "" >> /tmp/sysinfo.$$.disk_rev
  fi

  if (($EMC_found))
  then
    Debug "calling EMC query routine"
    #query_EMC_disks

  fi
#
# check for boot path settings
#
  if [[ -f /usr/sbin/setboot ]]
  then
    pri_boot_path=$(/usr/sbin/setboot | grep Primary | awk '{print $4}')
    alt_boot_path=$(/usr/sbin/setboot | grep Alternate | awk '{print $4}')
    auto_boot=$(/usr/sbin/setboot | grep Autoboot | awk '{print $3}')
    auto_search=$(/usr/sbin/setboot | grep Autosearch | awk '{print $3}' )
    print "" >> /tmp/sysinfo.$$.boot
    print "Primary Boot Path   = ${pri_boot_path}" >> /tmp/sysinfo.$$.boot
    print "Alternate Boot Path = ${alt_boot_path}" >> /tmp/sysinfo.$$.boot
    print "Autoboot            = ${auto_boot}"     >> /tmp/sysinfo.$$.boot
    print "Autosearch          = ${auto_search}"   >> /tmp/sysinfo.$$.boot
  fi
  print  "\n" >> /tmp/sysinfo.$$.boot

# now print out totals
### Changed 6/16/99 J.Semroc sort LU numerically
###  sort -k2. -o /tmp/sysinfo.$$.physinfos /tmp/sysinfo.$$.physinfo
  sort -k2n -o /tmp/sysinfo.$$.physinfos /tmp/sysinfo.$$.physinfo
### end of Change
  rm -f /tmp/sysinfo.$$.physinfo 2>&1
  print
# print     "" >> /tmp/sysinfo.$$.physinfoh
  print  -n "                         " >> /tmp/sysinfo.$$.physinfoh
  print     "                                               Size" >> /tmp/sysinfo.$$.physinfoh
  print  -n " Volume Name      LU#         " >> /tmp/sysinfo.$$.physinfoh
  print     "     H/W Path     Vendor  /  Model        (MB)  B" >> /tmp/sysinfo.$$.physinfoh
  print  -n " --------------   ---       " >> /tmp/sysinfo.$$.physinfoh
  print     " ----------------  --------------------    ------ -" >> /tmp/sysinfo.$$.physinfoh
  print     "                                                                       ======" >> /tmp/sysinfo.$$.physinfot
  print  -n "                                                   Total (MB)" >> /tmp/sysinfo.$$.physinfot
  print     "     ${total_p_mb}" >> /tmp/sysinfo.$$.physinfot
### Changed 6/15/99 J.Semroc - generated the following error
###  "cat: Cannot use /tmp/sysinfo.14950.physinfod as both input and output."
###  cat /tmp/sysinfo.$$.physinfo? > /tmp/sysinfo.$$.physinfod
  cat /tmp/sysinfo.$$.physinfo? > /tmp/sysinfo.$$.PHYSINFOD
  mv /tmp/sysinfo.$$.PHYSINFOD /tmp/sysinfo.$$.physinfod
### end of Change
  print "B = Bootable Disk" >> \
             /tmp/sysinfo.$$.physinfod
  print "n/v = Not Valid, n/f = Not Found\n" >> \
             /tmp/sysinfo.$$.physinfod
  f_display_file /tmp/sysinfo.$$.physinfod
  print "" >> /tmp/sysinfo.$$.physwarn
  f_display_file /tmp/sysinfo.$$.physwarn
  f_display_file /tmp/sysinfo.$$.disk_rev
  if [[ -f  /tmp/sysinfo.$$.inq256 ]]
  then
    f_display_file /tmp/sysinfo.$$.256header
    print "" >> /tmp/sysinfo.$$.inq256
    f_display_file /tmp/sysinfo.$$.inq256
  fi

  if [[ -f  /tmp/sysinfo.$$.array ]]
  then
    f_display_file /tmp/sysinfo.$$.arrayheader
    print "\n\n" >> /tmp/sysinfo.$$.array
    f_display_file  /tmp/sysinfo.$$.array
  fi

  f_display_file /tmp/sysinfo.$$.boot
  if (($PMAP))
  then
    f_display_file /tmp/sysinfo.$$.pmap
  fi
  
}                # end of f_get_physical_disk_data

#===================================================================
# f_get_ioscan_data
#===================================================================
function f_get_ioscan_data
{
  Debug "  calling check_if_scan_done"
  check_if_scan_done io_scan
  GREP_V_ARGS="-eboot_console $GREP_V_ARGS"
  if (($HTML))
  then
    print "</PRE>"                          >> /tmp/sysinfo.$$.ioout
    print "<A NAME='IO'></A>"               >> /tmp/sysinfo.$$.ioout
    print "<H2>"                            >> /tmp/sysinfo.$$.ioout
    print "<P ALIGN=RIGHT><A HREF='#Top'>TOP</A></P>" >> /tmp/sysinfo.$$.ioout
    print "<FONT COLOR=red>"                >> /tmp/sysinfo.$$.ioout
    print "I/O Configuration Data</H2>"     >> /tmp/sysinfo.$$.ioout
    print "</FONT><PRE><font size = '4'>"   >> /tmp/sysinfo.$$.ioout
  else
    print "I/O CONFIGURATION DATA" >> /tmp/sysinfo.$$.ioout
    print "======================" >> /tmp/sysinfo.$$.ioout
  fi
  print "" >> /tmp/sysinfo.$$.ioout
  print "              H/W Path       Driver  Identifier String" >>/tmp/sysinfo.$$.ioout
  print "              --------       ------  -----------------" >>/tmp/sysinfo.$$.ioout
 
  Debug "  `cat ${io_scan_out}`"
  if (( ${osmajor} >= 10 ))
  then
    Debug "found 10.x or later"
    Debug "sending $io_scan_out to formatter"
    Debug "  GREP_V_ARGS = $GREP_V_ARGS"

    cat $io_scan_out | weed_targets | formatter | \
        grep -F -v $GREP_V_ARGS >> /tmp/sysinfo.$$.ioout
  else
    Debug "found 9.x"
    cp ${io_scan_out} /tmp/sysinfo.$$.ioout
  fi
  Debug "  `cat /tmp/sysinfo.$$.ioout`"
  
  #rm -f $io_scan_tmp
  print "" >>/tmp/sysinfo.$$.ioout
  f_display_file /tmp/sysinfo.$$.ioout

}                # end of f_get_ioscan_data

#===================================================================
# f_get_volume_group_data
#        This function retrieves volume group data using vgdisplay
#        and by scannig /etc/lvmconf for config files.
#===================================================================
function f_get_volume_group_data
{
  Debug "Beginning VOLUME GROUP check."
  # first print header information

  if (($HTML))
  then
    print "</PRE>"                     >> /tmp/sysinfo.$$.vginfoh
    print "<A NAME='Volume'></A>"      >> /tmp/sysinfo.$$.vginfoh
    print "<H2>"                       >> /tmp/sysinfo.$$.vginfoh
    print "<P ALIGN=RIGHT><A HREF='#Top'>TOP</A></P>" >> /tmp/sysinfo.$$.vginfoh
    print "<FONT COLOR=red>"           >> /tmp/sysinfo.$$.vginfoh
    print "Volume Group Data</H2>"     >> /tmp/sysinfo.$$.vginfoh
    print "</FONT><PRE><font size = '4'>"     >> /tmp/sysinfo.$$.vginfoh
  else
    print                     >> /tmp/sysinfo.$$.vginfoh
    print "VOLUME GROUP DATA" >> /tmp/sysinfo.$$.vginfoh
    print "=================" >> /tmp/sysinfo.$$.vginfoh
  fi
  Debug "  calling check_if_scan_done"
  check_if_scan_done lvm_scan

  vgdisplay -v > /tmp/sysinfo.$$.vgout 2>&1
  #MWR fix when PVG-strict policies used
  #all_volgroups=$(grep "VG Name" /tmp/sysinfo.$$.vgout | awk '{print $3}' | sort)
  all_volgroups=$(grep -v "PVG Name" /tmp/sysinfo.$$.vgout | \
     grep "VG Name" | awk '{print $3}' | sort)
  all_logvols=$(grep "LV Name" /tmp/sysinfo.$$.vgout | awk '{print $3}' | sort)
  #Debug "all_volgroups=\n$all_volgroups"
  #Debug "all_logvols=\n$all_logvols"
  
  print -n "scanning volume groups "
  for volgroup in ${all_volgroups}
  do
    Debug "Volumegroup = $volgroup"
    vgdisplay $volgroup > /tmp/sysinfo.$$.volgroup 2>&1
    #Debug "vgdisplay=\n`cat /tmp/sysinfo.$$.volgroup`"
    ((vgcount=vgcount + 1))
    CURLV=$(grep "Cur LV" /tmp/sysinfo.$$.volgroup | awk '{print $3}')
    CURPV=$(grep "Cur PV" /tmp/sysinfo.$$.volgroup | awk '{print $3}')
    AllocPe=$(grep "Alloc PE" /tmp/sysinfo.$$.volgroup | awk '{print $3}')
    FreePe=$(grep "Free PE" /tmp/sysinfo.$$.volgroup | awk '{print $3}')
    TotalPe=$(grep "Total PE" /tmp/sysinfo.$$.volgroup | awk '{print $3}')
    PeSize=$(grep "PE Size" /tmp/sysinfo.$$.volgroup | awk '{print $4}')
    ((AllocMb = AllocPe * PeSize))
    ((FreeMb = FreePe * PeSize))
    ((TotalMb = TotalPe * PeSize))
    ((TotalAllocMb = TotalAllocMb + AllocMb))
    ((TotalFreeMb = TotalFreeMb + FreeMb))
    ((SystemTotalMb = SystemTotalMb + TotalMb))
    Debug "  Physical Extent Size = ${PeSize}"
    Debug "  Number of Allocated Physical Extents = ${AllocPe}"
    Debug "  Free Physical Extents = ${FreePe}"
    Debug "  Total Physical Extents = ${TotalPe}"
    Debug "  Allocated Mb = ${AllocMb}"
    Debug "  Free Mb = ${FreeMb}"
    Debug "  Total Mb = ${TotalMb}"
    Debug "  Total Allocated Mb = ${TotalAllocMb}"
    Debug "  Total Free Mb = ${TotalFreeMb}"
    Debug "  System Total Mb = ${SystemTotalMb}"
    print -n "."
    print -n "${volgroup}${CURLV}${CURPV}${PeSize}" >> /tmp/sysinfo.$$.vginfos
    print    "${AllocMb}${FreeMb}${TotalMb}" >> /tmp/sysinfo.$$.vginfos
  done
  print  
  Debug "Checking for vgcount = maxvgs"
  if [[ -z $maxvgs ]]
  then
    maxvgs=$(echo 'maxvgs/D'|adb -k $kernel /dev/kmem \
             | tail -1 | awk '{print $2}')
  fi
  Debug " vgcount = $vgcount"
  Debug " maxvgs = $maxvgs"
  if ((vgcount == maxvgs))
  then
    if ((! (($exit_code)) ))
    then
      exit_code=${WARN}
    fi
    print "WARNING (${sysname}): number of volume groups is at maximum."\
           >> /tmp/sysinfo.$$.errwarn
  fi
  
# now check for a cfg backup file for each volume group.

  print -n "scanning config files "
  Debug "Checking vg config files"
  for volgroup in ${all_volgroups}
  do
    Debug "  volgroup ${volgroup}"
    vg=$(echo ${volgroup} | awk -F/ '{print $3}')
    print -n "."
    if [ -f /etc/lvmconf/${vg}.conf ]
    then
      # this is a kludge. if file is less than 6 months old then 
      # ls -l prints the time, so scan for a colon.
      ls -l /etc/lvmconf/${vg}.conf | awk '{print $8}' | grep ":" > /dev/null
      if (($?))
      then
        if ((! (($exit_code)) ))
        then
          exit_code=${WARN}
        fi
        print "WARNING (${sysname}): vgconfig file > 6 months old for /etc/lvmconf/${vg}.conf"\
               >> /tmp/sysinfo.$$.errwarn
      fi
    else
      if ((! (($exit_code)) ))
      then
        exit_code=${WARN}
      fi
      print -n "WARNING (${sysname}): no config " >> /tmp/sysinfo.$$.errwarn
      print    "file found for volume group ${vg}." >> /tmp/sysinfo.$$.errwarn
      if ((! (($exit_code)) ))
      then
        exit_code=${WARN}
      fi
    fi
  done
  print  ""
  f_display_file /tmp/sysinfo.$$.novgcfg 
  print    "" >> /tmp/sysinfo.$$.vginfoh
  print    " Volume               Logical  Physical  Extent   MBs of Physical Space" >> /tmp/sysinfo.$$.vginfoh
  print    " Group                Volumes  Volumes  Size(MB)  Alloc    Free   Total"  >> /tmp/sysinfo.$$.vginfoh
  print    " ---------            -------  --------  ------   -----    ----   -----"  >> /tmp/sysinfo.$$.vginfoh
  print    "                                                  =====    ====   =====" >> /tmp/sysinfo.$$.vginfot
  print -n "                                        Totals " >> /tmp/sysinfo.$$.vginfot
  print     "${TotalAllocMb}${TotalFreeMb}${SystemTotalMb}" >> /tmp/sysinfo.$$.vginfot
  cat /tmp/sysinfo.$$.vginfo? > /tmp/sysinfo.$$.vginfod
  f_display_file /tmp/sysinfo.$$.vginfod

} # end of f_get_volume_group_data

#===================================================================
# f_get_logical_volume_data
#        This function uses lvdisplay to scan logical volumes.
#        It retrieves information about the logvol and also checks
#        for stale mirrors (if used).
#===================================================================
function f_get_logical_volume_data
{
  Debug "Beginning LOGICAL DISK check."
  # first print out header information
  
  if (($HTML))
  then
    print "</PRE>"                                  >> /tmp/sysinfo.$$.lvinfoh
    print "<A NAME='Logical'></A>"                  >> /tmp/sysinfo.$$.lvinfoh
    print "<H2>"                                    >> /tmp/sysinfo.$$.lvinfoh
    print "<P ALIGN=RIGHT><A HREF='#Top'>TOP</A></P>" >> /tmp/sysinfo.$$.lvinfoh
    print "<FONT COLOR=red>"           >> /tmp/sysinfo.$$.lvinfoh
    print "Logical Volume And Extent Data</H2>"     >> /tmp/sysinfo.$$.lvinfoh
    print "</FONT><PRE><font size = '4'>"           >> /tmp/sysinfo.$$.lvinfoh
  else
    print                                     >> /tmp/sysinfo.$$.lvinfoh
    print  "LOGICAL VOLUME AND EXTENT DATA"   >> /tmp/sysinfo.$$.lvinfoh  
    print  "=============================="   >> /tmp/sysinfo.$$.lvinfoh
  fi
  Debug "  calling check_if_scan_done"
  check_if_scan_done lvm_scan
  
  print -n "scanning logical volumes "
  if [[ ! -f /tmp/sysinfo.$$.vgout ]]
  then
    vgdisplay -v > /tmp/sysinfo.$$.vgout 2>&1
    all_volgroups=$(grep "VG Name" /tmp/sysinfo.$$.vgout | awk '{print $3}' | sort)
    all_logvols=$(grep "LV Name" /tmp/sysinfo.$$.vgout | awk '{print $3}' | sort)
  fi
  for logvol in ${all_logvols}
  do
    Debug "lvdisplay of ${logvol}"
    lvol_major=$(ls -l $logvol | awk '{print $5}')
    lvol_minor=$(ls -l $logvol | awk '{print $6}')
    Debug "  major= $lvol_major minor=$lvol_minor"
    lvdisplay -v ${logvol} > /tmp/sysinfo.$$.logical 2>&1
    STATUS=$(grep "LV Status" /tmp/sysinfo.$$.logical | awk '{print $3}')
    LVSize=$(grep "LV Size" /tmp/sysinfo.$$.logical | awk '{print $4}')
    LogicalExtents=$(grep "Current LE" /tmp/sysinfo.$$.logical \
                  | awk '{print $3}')
    StaleExtents=$(grep stale /tmp/sysinfo.$$.logical | wc -l)
    MirrorCopies=$(grep "Mirror copies" /tmp/sysinfo.$$.logical \
                  | awk '{print $3}')
    Consistency=$(grep "Consistency Recovery" /tmp/sysinfo.$$.logical \
                  | awk '{print $3}')
  
  
    ((total_l_mb = total_l_mb + LVSize))
    ((MirrorMb = LVSize * MirrorCopies))
    ((TotalMirrorMb = TotalMirrorMb + MirrorMb))
    
  # check to make sure lvol has extents allocated to it
    if (( $LogicalExtents > 0 ))                 
    then
### Changed 6/15/99 J.Semroc - grep for lvol1 would also match lvol10, lvol11...
###   MOUNT=$(cat /etc/mnttab | grep ${logvol}  | cut -f 2 -d" ")
      MOUNT=$(cat /etc/mnttab | grep "${logvol} " | cut -f 2 -d" ")
### end of Change
      if [[ ${swap_devs} = *${logvol}* ]]
      then
        MOUNT="(swapdisk)"
      fi
      ((lcount=lcount + 1))
      if (( ${StaleExtents} > 0 ))        # we found stale extents
      then
        Debug " Found ${StaleExtents} STALE extents on ${logvol}!"
        stale=1
        ((StaleMB = (LVSize / LogicalExtents) * StaleExtents ))
        ((TotalStaleMb = TotalStaleMb + StaleMB))
        ((total_stale = $total_stale + $StaleExtents))
      fi                                # end of stale extents
    else                                # no extents allocated
      if ((! (($exit_code)) ))
      then
        exit_code=$WARN
      fi
      zero_length=1
      print -n "\nWARNING (${sysname}): Detected logical " >> /tmp/sysinfo.$$.errwarn
      print "volume (${logvol}) with no extents!\n" >> /tmp/sysinfo.$$.errwarn
    fi                                # end of check for allocated extents
    Debug "  STATUS= ${STATUS}"
    Debug "  LVSize= ${LVSize}"
    Debug "  LogicalExtents = ${LogicalExtents}"
    Debug "  StaleExtents = ${StaleExtents}"
    Debug "  StaleMb= $StaleMB"
    Debug "  TotalStaleMb= $TotalStaleMb "
    Debug "  TotalMb checked= $total_l_mb"

# now let's print out the results.
    print -n "."
    logvold=${logvol}                        # for display purposes only.
    print "${logvold}${MOUNT}"               >> /tmp/sysinfo.$$.lvinfos
    #print "${LogicalExtents}${StaleExtents}" >> /tmp/sysinfo.$$.lvinfos
    #print "${MirrorCopies}${Consistency}"    >> /tmp/sysinfo.$$.lvinfos
  done                                
# end of loop for all log vols
# now print out any errors or warnings.
  f_display_file /tmp/sysinfo.$$.nolvext 
# print    "" >> /tmp/sysinfo.$$.lvinfoh
  print    "                                     "  >> /tmp/sysinfo.$$.lvinfoh
  print -n " Volume Name                            " >> /tmp/sysinfo.$$.lvinfoh
  print    "Mounted File System"  >> /tmp/sysinfo.$$.lvinfoh
  print -n " --------------                         " >> /tmp/sysinfo.$$.lvinfoh
  print -- "--------------------"  >> /tmp/sysinfo.$$.lvinfoh
  print    "" >> /tmp/sysinfo.$$.lvinfos
  cat /tmp/sysinfo.$$.lvinfo? > /tmp/sysinfo.$$.lvinfod
  f_display_file /tmp/sysinfo.$$.lvinfod 

  print "\nAllocation" > /tmp/sysinfo.$$.lvol_legend
  print -n "  ns    non-strict                " >> /tmp/sysinfo.$$.lvol_legend
  print    "PVG-s  PVG-strict                " >> /tmp/sysinfo.$$.lvol_legend
  print -n "  ns-c  non-strict/contiguous     " >> /tmp/sysinfo.$$.lvol_legend
  print    "PVG-c  PVG-strict/contiguous" >> /tmp/sysinfo.$$.lvol_legend
  print -n "  s     strict                    " >> /tmp/sysinfo.$$.lvol_legend
  print    "PVG-d  PVG-strict/distributed    " >> /tmp/sysinfo.$$.lvol_legend
  print -n "  s-c   strict/contiguous         " >> /tmp/sysinfo.$$.lvol_legend
  print    "PVG-p  PVG-strict/partially-distributed" >> /tmp/sysinfo.$$.lvol_legend
  print "" >> /tmp/sysinfo.$$.lvol_legend


# display using data from batch lvm_scan
  print    "" > /tmp/sysinfo.$$.lvinfoh
  print -n "                                 "  >> /tmp/sysinfo.$$.lvinfoh
  print    "                                  Bad" >> /tmp/sysinfo.$$.lvinfoh
  print -n "                                 "  >> /tmp/sysinfo.$$.lvinfoh
  print    "  Size Stripes    Mirrors    LV   Block" >> /tmp/sysinfo.$$.lvinfoh
  print -n " Volume Name                     "  >> /tmp/sysinfo.$$.lvinfoh
  print    "  (MB)  # Size    #  Const  State Reloc  Alloc" >> /tmp/sysinfo.$$.lvinfoh
  print -n " --------------                  "  >> /tmp/sysinfo.$$.lvinfoh
  print    " ----- -------   ---------  ----- -----  -----"  >> /tmp/sysinfo.$$.lvinfoh
  f_display_file /tmp/sysinfo.$$.lvinfoh
  f_display_file $lvol_out_file
  f_display_file /tmp/sysinfo.$$.lvol_legend
  if (($BATCH))
  then
    print
  fi

}         # end of f_get_logical_volume_data


#===================================================================
# f_logical_to_physical
#        This function produces a cross reference of physical disks
#        for each logical volume.
#===================================================================
function f_logical_to_physical
{
  Debug "Beginning LOGICAL TO PHYSICAL Mapping."
  
  if [[ ! -f /tmp/sysinfo.$$.vgout ]]
  then
    Debug "/tmp/sysinfo.$$.vgout not found....building."
    vgdisplay -v > /tmp/sysinfo.$$.vgout 2>&1
    all_logvols=$(grep "LV Name" /tmp/sysinfo.$$.vgout | awk '{print $3}' |sort)
  fi
  if (($HTML))
  then
    print "</PRE>"                                    >> /tmp/sysinfo.$$.l2p
    print "<A NAME='Lmap'></A>"                       >> /tmp/sysinfo.$$.l2p
    print "<H2>"                                      >> /tmp/sysinfo.$$.l2p
    print "<P ALIGN=RIGHT><A HREF='#Top'>TOP</A></P>" >> /tmp/sysinfo.$$.l2p
    print "<FONT COLOR=red>"                          >> /tmp/sysinfo.$$.l2p
    print "Logical Volume To Physical Disk Mapping</H2>" >> /tmp/sysinfo.$$.l2p
    print "</FONT><PRE><font size = '4'>"             >> /tmp/sysinfo.$$.l2p
  else
    print    "" >> /tmp/sysinfo.$$.l2p
    print    "LOGICAL VOLUME TO PHYSICAL DISK MAPPING                 " >> /tmp/sysinfo.$$.l2p
    print    "=========================================================" >> /tmp/sysinfo.$$.l2p
  fi
  print "Logical Volume" >> /tmp/sysinfo.$$.l2p
  print " extents  Primary disk     Mirror Disk 1    Mirror Disk 2" >> /tmp/sysinfo.$$.l2p
  print -- "---------------------------------------------------------" >> /tmp/sysinfo.$$.l2p
  print -n "generating disk mappings "

  for logvol in ${all_logvols}
  do
    Debug "  scanning ${logvol}"
    lvdisplay -v ${logvol} > /tmp/sysinfo.$$.logical 2>&1
    PhysicalDisks=$(awk '$1 ~ /\/dev\/dsk\/.*/ {printf "%s\n",$1}' \
                     /tmp/sysinfo.$$.logical \
                     | sed -e 's/\/dev\/dsk\///' | sort)
    # output physical disk data for each logical volume
    print    "${logvol}    " >> /tmp/sysinfo.$$.l2p
#   print -n "     Disks = " >> /tmp/sysinfo.$$.l2p

# count the number of physical disks found.
    diskcount=0
    for disk in ${PhysicalDisks}
    do
      ((diskcount = diskcount + 1))
      Debug "    disk = $disk"
    done
    Debug "    found $diskcount physical disks"
    lvdisplay -v $logvol | sed '1,/   LE/d' | awk '{print $2, $5, $8}' \
                     | sort | grep "dev" | uniq -c | awk \
                     '{printf "%6s %18s %16s %16s\n",$1,$2,$3,$4}' \
                     >> /tmp/sysinfo.$$.l2p
#   print "" >> /tmp/sysinfo.$$.l2p
    print -n "."
  done
  print "" >> /tmp/sysinfo.$$.l2p
  f_display_file /tmp/sysinfo.$$.l2p 
  print  ""

}        # end of f_logical_to_physical


#===================================================================
# f_filesystem_check
#        This function checks mounted filesystems and reports 
#        capcity information. It prints warnings if greater than
#        95% full.
#===================================================================

function f_filesystem_check
{
  Debug "Beginning FILE SYSTEM check."

  # first print out headers
  if (($HTML))
  then
    print "</PRE>"                    >> /tmp/sysinfo.$$.bdf_outh
    print "<A NAME='File'></A>"       >> /tmp/sysinfo.$$.bdf_outh
    print "<H2>"                      >> /tmp/sysinfo.$$.bdf_outh
    print "<P ALIGN=RIGHT><A HREF='#Top'>TOP</A></P>" >>/tmp/sysinfo.$$.bdf_outh
    print "<FONT COLOR=red>"          >> /tmp/sysinfo.$$.bdf_outh
    print "File System Data</H2>"     >> /tmp/sysinfo.$$.bdf_outh
    print "</FONT><PRE><font size = '4'>" >> /tmp/sysinfo.$$.bdf_outh
  else
    print    "" >> /tmp/sysinfo.$$.bdf_outh
    print    "FILE SYSTEM DATA" >> /tmp/sysinfo.$$.bdf_outh
    print    "================" >> /tmp/sysinfo.$$.bdf_outh
  fi
  print -n "scanning filesystems "

  typeset -R10 kbytes used avail iused ifree
  typeset -R5 percent_used
  mnttab=$(cat /etc/mnttab | grep /dev  | awk '{printf "%s\n", $2}')
  num_fs=$(bdf -il 2>&1 | grep "/dev/" | wc -l)
  ((num_fs = num_fs -1))
  Debug "Found $num_fs mounted file systems"
# bdf -i | tail -${num_fs} > /tmp/sysinfo.$$.bdf_data 2>&1
  for mounted in ${mnttab}
  do
    bdf -i ${mounted} 2>&1 | tail -1 > /tmp/sysinfo.$$.bdf_data 2>&1
    if ( grep "No such file" /tmp/sysinfo.$$.bdf_data >/dev/null 2>&1 )
    then 
      Debug " bdf reports No such file or directory on ${mounted}"
      print "WARNING (${sysname}): No such file or directory for ${mounted}" >>  /tmp/sysinfo.$$.errwarn
    else
    fs_type=$(cat /etc/mnttab | grep " ${mounted} " | awk '{printf "%s\n", $3}')
    Debug "filesys = ${mounted}  fs_type = ${fs_type}"
    if [[ $fs_type = vxfs ]]
    then
      mnt_lvol=$(cat /etc/mnttab | grep " ${mounted} " | awk '{printf "%s\n", $1}')
      fs_ver=$(fstyp -v ${mnt_lvol} 2>&1 | grep version | awk '{printf "%s\n", $2}')
      if [[ -f ${mounted}/lost+found/.fsadm ]]
      then
      vxfs_defrag=$(fsadm -F vxfs -E ${mounted} | grep \
                  "extents 64 blks or larger" | awk '{print $NF}')
      ((vxfs_frag = 100 - vxfs_defrag))
      vxfs_pct="%"
      else
        Debug " ${mounted}/lost+found/.fsadm not found - no frag check"
        no_lost=1
        vxfs_frag="**"
        vxfs_pct="*"
      fi
      Debug "fs_ver = ${fs_ver} vxfs_frag = ${vxfs_frag}"
      if ( [[ $osmajor = 10 ]] && [[ $osminor > 10 ]] ) || [[ $osmajor = 11 ]]
      then
        if [[ $fs_ver < 3 ]]
        then
          Debug "Found vxfs version $fs_ver"
          print "WARNING (${sysname}): Version ${fs_ver} of vxfs found on ${mounted}" >> /tmp/sysinfo.$$.errwarn
        fi
      fi
    fi
    Debug "  `cat /tmp/sysinfo.$$.bdf_data`"
    kbytes=$(awk '{if (NF == 9) print $2; else print $1}' /tmp/sysinfo.$$.bdf_data) 
    used=$(awk '{if (NF == 9) print $3; else print $2}' /tmp/sysinfo.$$.bdf_data)
    if [[ $fs_type  != "cdfs" ]]
    then
      avail=$(awk '{if (NF == 9) print $4; else print $3}' /tmp/sysinfo.$$.bdf_data)
      iused=$(awk '{if (NF == 9) print $6; else print $5}' /tmp/sysinfo.$$.bdf_data)
      ifree=$(awk '{if (NF == 9) print $7; else print $6}' /tmp/sysinfo.$$.bdf_data)
      #((percent_used = (used * 100) / (used + avail) ))
      percent_used=$(echo $used $avail | \
        awk '{ used = $1
               avail = $2
               pct_used =  ($1 * 100) / ($1 + $2)
               printf("%d", pct_used)
              } ' )

      if (($percent_used > 95)) && [[ $fs_type  != "cdfs" ]]
      then
        if ((! (($exit_code)) ))
        then
          exit_code=${WARN}
        fi
        print "WARNING (${sysname}): ${mounted} has less than 5% free space left!" >> /tmp/sysinfo.$$.errwarn
      fi
    else #must be a cdrom, so don't calculate free space
      avail=0
      iused="-"
      ifree="-"
      percent_used="-"
    fi
    if [[ $fs_type != vxfs ]]
    then
      vxfs_frag="n/"
      vxfs_pct="a"
    fi
    print "${mounted}" >> /tmp/sysinfo.$$.bdf_outs
#   print "              ${fs_type} ${kbytes}${used}${avail}${percent_used}${iused}${ifree}" >> /tmp/sysinfo.$$.bdf_outs
    print "              ${fs_type} ${kbytes}${used}${avail}${percent_used}     ${vxfs_frag}${vxfs_pct}" >> /tmp/sysinfo.$$.bdf_outs
    print -n "."
    fi
  done
  print "" >> /tmp/sysinfo.$$.bdf_outs
  print -n "Mounted                               " >> /tmp/sysinfo.$$.bdf_outh
  print -- "                    Extents" >> /tmp/sysinfo.$$.bdf_outh
  print -n "Filesystems   Type     Kbytes      Used     Avail" >> /tmp/sysinfo.$$.bdf_outh
# print    "   %      Iused     Ifree" >> /tmp/sysinfo.$$.bdf_outh
  print    "   %    Fragmented" >> /tmp/sysinfo.$$.bdf_outh
  print -n " ----------   ----     ------    ------    ------" >> /tmp/sysinfo.$$.bdf_outh
  print -- "  ---   ----------" >> /tmp/sysinfo.$$.bdf_outh
  cat /tmp/sysinfo.$$.bdf_out? > /tmp/sysinfo.$$.bdf_outd
  if (( ${no_lost} == 1 ))
  then
    print -n "***  could not get fsadm lock - " >> /tmp/sysinfo.$$.bdf_outd
    print "lost+found/.fsadm not found" >> /tmp/sysinfo.$$.bdf_outd
    print "" >> /tmp/sysinfo.$$.bdf_outd
  fi
  f_display_file /tmp/sysinfo.$$.bdf_outd 
  f_display_file /tmp/sysinfo.$$.bdf_warn 
  print ""

}        # end of f_filesystem_check

#===================================================================
# f_disk_capacity
#        This function displays total disk, group, and lvol capacities.
#        The data comes from the logical, physical, & volume functions.
#        Therefore, this function does not stand alone. It must be run
#        with the l, p, & v options.
#===================================================================
function f_disk_capacity
{
  Debug "Beginning DISK CAPACITY calculations."
  if (($HTML))
  then
    print "</PRE>"                      >> /tmp/sysinfo.$$.capacity
    print "<A NAME='Capacity'></A>"     >> /tmp/sysinfo.$$.capacity
    print "<H2>"                        >> /tmp/sysinfo.$$.capacity
    print "<P ALIGN=RIGHT><A HREF='#Top'>TOP</A></P>" >>/tmp/sysinfo.$$.capacity
    print "<FONT COLOR=red>"          >> /tmp/sysinfo.$$.capacity
    print "Disk Capacity Data</H2>"     >> /tmp/sysinfo.$$.capacity
    print "</FONT><PRE><font size = '4'>" >> /tmp/sysinfo.$$.capacity
  else
    print "DISK CAPACITY DATA" >> /tmp/sysinfo.$$.capacity
    print "==================" >> /tmp/sysinfo.$$.capacity
  fi
  ((unused_cap = total_p_mb - TotalAllocMb))
  ((OtherMb = TotalAllocMb - total_l_mb - TotalMirrorMb))
  print "Logical Volume Space  =    $total_l_mb MB" >> /tmp/sysinfo.$$.capacity
  print "Mirror Space          =    $TotalMirrorMb MB" >> /tmp/sysinfo.$$.capacity
  print "Other Space Allocated =    $OtherMb MB" >> /tmp/sysinfo.$$.capacity
  print "                        -----------" >> /tmp/sysinfo.$$.capacity
  print "Total Disk Allocated  =    $TotalAllocMb MB" >> /tmp/sysinfo.$$.capacity
  print "Unallocated Disk      =    $unused_cap MB" >> /tmp/sysinfo.$$.capacity
  print "                        ===========" >> /tmp/sysinfo.$$.capacity
  print "Total Physical Disk   = $total_p_mb MB\n" >> /tmp/sysinfo.$$.capacity

  print "Checked:" >> /tmp/sysinfo.$$.capacity
  print "${pcount} physical volumes" >> /tmp/sysinfo.$$.capacity
  print "${vgcount} volume groups" >> /tmp/sysinfo.$$.capacity
  print "${lcount} logical volumes" >> /tmp/sysinfo.$$.capacity

  Debug "  found ${pcount} physical volumes"
  Debug "  found ${vgcount} volume groups"
  Debug "  found ${lcount} logical volumes"
  
  if  ((${stale}))
  then
    Debug "found ${total_stale} STALE extents"
    Debug "  calculating re-syncing time"
    exit_code=${SYS_ERROR}
    print "STALE extents detected!" >> /tmp/sysinfo.$$.capacity
    print "  check error listing for more details." >> /tmp/sysinfo.$$.capacity
    print -n "\n\nERROR:${sysname}: ${total_stale}" >> /tmp/sysinfo.$$.errwarn
    print    " stale extents detected.\n" >> /tmp/sysinfo.$$.errwarn
    print -n "Estimated time to re-sync ${total_stale}" >> /tmp/sysinfo.$$.errwarn
    print    " stale extents is" >> /tmp/sysinfo.$$.errwarn
    if ((${TotalStaleMb} < 100))
    then
      print " less than 1 minute." >> /tmp/sysinfo.$$.errwarn
      Debug " less than 1 minute" 
    else
      ((TIME = TotalStaleMb / 100))
      ((HOURS = TIME /60))
      ((MINUTES = TIME % 60))
      print " ${HOURS} hours and ${MINUTES} minutes." >> /tmp/sysinfo.$$.errwarn
      Debug " ${TIME} total minutes or" 
      Debug "     ${HOURS} hours and ${MINUTES} minutes" 
    fi
    print >> /tmp/sysinfo.$$.errwarn
  else
    print "with no stale extents detected.\n"   >> /tmp/sysinfo.$$.capacity
    Debug "No stale extents detected"
  fi
  f_display_file /tmp/sysinfo.$$.capacity

}                 # end of f_disk_capacity


#===================================================================
# f_check_root
#        This function checks to see if the user is root.
#===================================================================
function f_check_root
{
  id | grep '(root)' > /dev/null
  if (($?))
  then
    print "\nYou must be super-user to run ${script}.\n"
    exit ${ERROR}
  fi
}                # end of check_root

#===================================================================
# f_check_hpux
#        This function checks to see if running on HP-UX
#===================================================================
function f_check_hpux
{
  uname -s | grep HP-UX > /dev/null
  if (($?))
  then
    print "\nThis utility is only supported on HP-UX systems!\n"
    exit ${ERROR}
  fi
}                # end of check_hpux

#===================================================================
# f_extract_errors
#        This function extract WARNINGS & ERRORS from the logfile
#===================================================================
function f_extract_errors
{
  if [[ -f /tmp/sysinfo.$$.errwarn ]]
  then
    if (($HTML))
    then
      print "</PRE>"                          >> /tmp/sysinfo.$$.errwarn.header
      print "<A NAME='ErrWarn'></A>"          >> /tmp/sysinfo.$$.errwarn.header
      print "<H2>"                            >> /tmp/sysinfo.$$.errwarn.header
      print "<P ALIGN=RIGHT><A HREF='#Top'>"  >> /tmp/sysinfo.$$.errwarn.header
      print "TOP</A></P>"                     >> /tmp/sysinfo.$$.errwarn.header
      print "<FONT COLOR=red>"                >> /tmp/sysinfo.$$.errwarn.header
      print "Summary of Errors/Warnings</H2>" >> /tmp/sysinfo.$$.errwarn.header
      print "</FONT><PRE><font size = '4'>"   >> /tmp/sysinfo.$$.errwarn.header
    else
      print ""                                >> /tmp/sysinfo.$$.errwarn.header
      print "ERROR/WARNING SUMMARY"           >> /tmp/sysinfo.$$.errwarn.header
      print "====================="           >> /tmp/sysinfo.$$.errwarn.header
    fi

    grep  -e WARNING -e ERROR /tmp/sysinfo.$$.errwarn > /dev/null 2>&1
    if [ $? -eq 1 ]
    then
      Debug "No errors/warnings found."
      if (($BATCH))
      then
        print "No ERRORS or WARNINGS found."
      fi
      print "($sysname): No errors/warnings found." >> /tmp/sysinfo.$$.errwarn
    else
      Debug "Found errors/warnings, displaying /tmp/sysinfo.$$.errwarn"
      if (($BATCH))
      then
        print "Errors and/or Warnings were found." 
        print "Please check output file ${LOGFILE}."
      fi
    fi
    print "" >> /tmp/sysinfo.$$.errwarn
    f_display_file /tmp/sysinfo.$$.errwarn.header
    f_display_file /tmp/sysinfo.$$.errwarn
  else
    print "Could not find /tmp/sysinfo.$$.errwarn"
  fi
}

function print_header
{
#print
#print " ****             *****"
#print "*                   *                       "
#print "*     *   *  ***    *   **   * ****  **** "
#print " ****  * *  *       *   * *  * *    *    *"
#print "     *  *    ***    *   *  * * ***  *    *"
#print "     *  *       *   *   *   ** *    *    *"
#print " ****   *    ***  ***** *    * *     ****"
#print
print
print " @@@@             @@@@@"
print "@                   @                       "
print "@     @   @  @@@    @   @@   @ @@@@  @@@@ "
print " @@@@  @ @  @       @   @ @  @ @    @    @"
print "     @  @    @@@    @   @  @ @ @@@  @    @"
print "     @  @       @   @   @   @@ @    @    @"
print " @@@@   @    @@@  @@@@@ @    @ @     @@@@"
print
}
#===================================================================
# BEGIN MAIN CODE
#===================================================================
typeset -fx lvm_scan
typeset -fx sam_scan
typeset -fx io_scan
typeset -fx f_query_sam
sysname=$(hostname)
where=`dirname ${0}`
f_check_hpux
f_check_root
get_args $*
if (($BATCH))
then
  #print "\n${script}  ${version} by Scott Truesdale\n"
  print_header
  print "Author:  Scott Truesdale"
  print "Version: ${version}\n"
  if (($HTML))
  then
    print "<HTML><HEAD>"                                 >> $LOGFILE
    print "<HTML><HEAD>"                                 >> $LOGFILE_INDEX
    print "<HTML><HEAD>"                                 >> $LOGFILE_MAIN
    print "<TITLE>Sysinfo for ${sysname}</TITLE>"        >> $LOGFILE
    print "<TITLE>Sysinfo (Index) for ${sysname}</TITLE>" >> $LOGFILE_INDEX
    print "<TITLE>Sysinfo (Main) for ${sysname}</TITLE>" >> $LOGFILE_MAIN
    print "</HEAD>"                                      >> $LOGFILE
    print "<FRAMESET ROWS='175,*' FRAMEBORDER='YES'"     >> $LOGFILE
    print "BORDERCOLOR='darkblue' FRAMESPACING='2'"      >> $LOGFILE
    print "BORDER='2'>"                                  >> $LOGFILE
    print "<FRAME SRC='${LOGFILE_INDEX_REL}'"            >> $LOGFILE
    print "NAME='IndexFrame' SCROLLING='NO'>"            >> $LOGFILE
    print "<FRAME SRC='${LOGFILE_MAIN_REL}'"             >> $LOGFILE
    print "NAME='MainFrame'"                             >> $LOGFILE
    print "SCROLLING='AUTO'><NOFRAMES>"                  >> $LOGFILE
    print "<BODY BGCOLOR=lightblue>"                     >> $LOGFILE
    print "</HEAD><BODY BGCOLOR=lightblue>"              >> $LOGFILE_INDEX
    print "</HEAD><BODY BGCOLOR=lightblue>"              >> $LOGFILE_MAIN
    print "<CENTER>"                                     >> $LOGFILE
    print "<A name='TOP'></A>"                           >> $LOGFILE
    print "<FONT SIZE=6 COLOR=darkblue>"                 >> $LOGFILE
    print "${script} ${version} "                        >> $LOGFILE
    print "by Scott Truesdale</FONT><BR>"                >> $LOGFILE
    print "<FONT SIZE=6>Configuration Data for"          >> $LOGFILE
    print "<FONT COLOR=red>${sysname}</FONT></FONT><BR>" >> $LOGFILE
    print "<FONT SIZE=3>Collected on `date`.</FONT><BR>" >> $LOGFILE
    print "<A HREF='#System'>System</A>"                 >> $LOGFILE
    print "<A HREF='#Kernel'>Kernel</A>"                 >> $LOGFILE
    print "<A HREF='#Network'>Network</A>"               >> $LOGFILE
    print "<A HREF='#File'>File System</A>"              >> $LOGFILE
    print "<BR>"                                         >> $LOGFILE
    print "<A HREF='#IO'>IO Configuration</A>"           >> $LOGFILE
    print "<A HREF='#Physical'>Physical Disks</A>"       >> $LOGFILE
    print "<A HREF='#Pmap'>Physical Mapping</A>"         >> $LOGFILE
    print "<A HREF='#Volume'>Volume Groups</A>"          >> $LOGFILE
    print "<BR>"                                         >> $LOGFILE
    print "<A HREF='#Logical'>Logical Disks</A>"         >> $LOGFILE
    print "<A HREF='#Lmap'>Logical Mapping</A>"          >> $LOGFILE
    print "<A HREF='#Capacity'>Disk Capacity</A>"        >> $LOGFILE
    print "<A HREF='#Software'>Software List</A>"        >> $LOGFILE
    print "<BR>"                                         >> $LOGFILE
    print "<A HREF='#SYSACCESS'>Security Check</A>"      >> $LOGFILE
    print "<A HREF='#DIAGNOSTICS'>Diagnostic Settings</A>" >> $LOGFILE
    print "<A HREF='#LOGFILES'>System Logfiles</A>"      >> $LOGFILE
    print "<A HREF='#ErrWarn'>Errors/Warnings</A>"       >> $LOGFILE
    if (($PASS))
    then
      print "<BR>"                                       >> $LOGFILE
      print "<A HREF='#SAP'>SAP R/3 Info</A>"            >> $LOGFILE
    fi
    print "</CENTER>"                                    >> $LOGFILE
    print "<CENTER>"                                     >> $LOGFILE_INDEX
    print "<A name='TOP'></A>"                           >> $LOGFILE_INDEX
    print "<FONT SIZE=6 COLOR=darkblue>"                 >> $LOGFILE_INDEX
    print "${script} ${version} "                        >> $LOGFILE_INDEX
    print "by Scott Truesdale</FONT><BR>"                >> $LOGFILE_INDEX
    print "<FONT SIZE=6>Configuration Data for"          >> $LOGFILE_INDEX
    print "<FONT COLOR=red>${sysname}</FONT></FONT><BR>" >> $LOGFILE_INDEX
    print "<FONT SIZE=3>Collected on `date`.</FONT><BR>" >> $LOGFILE_INDEX
    print "<A HREF='${LOGFILE_MAIN_REL}#System' TARGET='MainFrame'>System</A>"                 >> $LOGFILE_INDEX
    print "<A HREF='${LOGFILE_MAIN_REL}#Kernel' TARGET='MainFrame'>Kernel</A>"                 >> $LOGFILE_INDEX
    print "<A HREF='${LOGFILE_MAIN_REL}#Network' TARGET='MainFrame'>Network</A>"               >> $LOGFILE_INDEX
    print "<A HREF='${LOGFILE_MAIN_REL}#File' TARGET='MainFrame'>File System</A>"              >> $LOGFILE_INDEX
    print "<A HREF='${LOGFILE_MAIN_REL}#IO' TARGET='MainFrame'>IO Configuration</A>"           >> $LOGFILE_INDEX
    print "<A HREF='${LOGFILE_MAIN_REL}#Physical' TARGET='MainFrame'>Physical Disks</A>"       >> $LOGFILE_INDEX
    print "<A HREF='${LOGFILE_MAIN_REL}#Pmap' TARGET='MainFrame'>Physical Mapping</A>"         >> $LOGFILE_INDEX
    print "<A HREF='${LOGFILE_MAIN_REL}#Volume' TARGET='MainFrame'>Volume Groups</A>"          >> $LOGFILE_INDEX
    print "<A HREF='${LOGFILE_MAIN_REL}#Logical' TARGET='MainFrame'>Logical Disks</A>"         >> $LOGFILE_INDEX
    print "<A HREF='${LOGFILE_MAIN_REL}#Lmap' TARGET='MainFrame'>Logical Mapping</A>"          >> $LOGFILE_INDEX
    print "<A HREF='${LOGFILE_MAIN_REL}#Capacity' TARGET='MainFrame'>Disk Capacity</A>"        >> $LOGFILE_INDEX
    print "<A HREF='${LOGFILE_MAIN_REL}#Software' TARGET='MainFrame'>Software List</A>"        >> $LOGFILE_INDEX
    print "<A HREF='${LOGFILE_MAIN_REL}#SYSACCESS' TARGET='MainFrame'>Security Check</A>"      >> $LOGFILE_INDEX
    print "<A HREF='${LOGFILE_MAIN_REL}#DIAGNOSTICS' TARGET='MainFrame'>Diagnostic Settings</A>" >> $LOGFILE_INDEX
    print "<A HREF='${LOGFILE_MAIN_REL}#LOGFILES' TARGET='MainFrame'>System Logfiles</A>"      >> $LOGFILE_INDEX
    print "<A HREF='${LOGFILE_MAIN_REL}#ErrWarn' TARGET='MainFrame'>Errors/Warnings</A>"       >> $LOGFILE_INDEX
    if (($PASS))
    then
      print "<A HREF='${LOGFILE_MAIN_REL}#SAP' TARGET='MainFrame'>SAP R/3 Info</A>"            >> $LOGFILE_INDEX
    fi
    print "</CENTER>"                                    >> $LOGFILE_INDEX

  else
    print "\n${script} ${version} by Scott Truesdale\n" >> $LOGFILE
    print "Configuration data for ${sysname}\ncollected on `date`\n" >> $LOGFILE
  fi
else
  print_header
  print "Author:  Scott Truesdale"
  print "Version: ${version}\n"
  print "Configuration data for ${sysname}\ncollected on `date`.\n" 
fi
touch /tmp/sysinfo.$$.errwarn
#===================================================================
# Begin PASS section
#===================================================================
if (($PASS))
then
  touch /tmp/sysinfo.$$.sapwarn
  check_for_sap
fi

#===================================================================
#  SYSTEM CHECK AND ROOT DATA 
#===================================================================
f_get_sys_type

if (($SYSTEM))
then
  f_get_system_data
fi
#===================================================================
# KERNEL DATA 
#===================================================================
if (($FULL_KERNEL)) || (($LITE_KERNEL))
then
  if (( ${osmajor} >= 10 ))
  then
    f_get_kernel_data
  else
    f_get_9x_kernel_data
  fi
fi

#if (($SAMSCAN)) && (( ${osmajor} >= 10 ))
#then
#  f_display_sam_kernel_data
#fi

#===================================================================
# NETWORK CARD DATA
#===================================================================
if (($NETWORK))
then
  f_get_network_data
fi

#===================================================================
# FILE SYSTEM CHECK
#===================================================================
if (($FILESYSTEM))
then
  f_filesystem_check
fi

#===================================================================
# IOSCAN CHECK
#===================================================================
if (($IOSCAN))
then
  f_get_ioscan_data
fi

#===================================================================
# PHYSICAL DISK CHECK
#===================================================================
if (($PHYSICAL))
then
  f_get_physical_disk_data
fi

#===================================================================
# VOLUME GROUP CHECK
#===================================================================
if (($VOLUMES)) 
then
  if (($lvm_installed))
  then
    f_get_volume_group_data
  else
    print "LVM must be installed to use this option."
  fi
fi

#===================================================================
# LOGICAL DISK CHECK
#===================================================================
if (($LOGICAL)) 
then
  if (($lvm_installed))
  then
    f_get_logical_volume_data
  else
    print "LVM must be installed to use this option."
  fi
fi

#===================================================================
# LOGICAL VOLUME TO PHYSICAL DISK MAPPING 
#===================================================================
# check which physical disks have this logvol on them
if (($LMAP))
then
  if (($lvm_installed))
  then
    f_logical_to_physical
  else
    print "LVM must be installed to use this option."
  fi
fi

#===================================================================
# DISK CAPACITY TABLE
#===================================================================
# note that the CAPACITY flag cannot be set directly.
# it is automatically enabled when either the -a or -lpv flags
if (($CAPACITY))
then
  if (($lvm_installed))
  then
    f_disk_capacity
  else
    print "LVM must be installed to use this option."
  fi
fi

#===================================================================
# SOFTWARE LIST
#===================================================================
if (($SWLIST))
then
  sw_scan
fi

#===================================================================
# Check system file/directory access and some security parms.
#===================================================================
if (($FILEACCESS))
then
  chk_sysaccess
fi

#===================================================================
# Check to see if the system has diagnostics
#===================================================================
if (($DIAGNOSTICS))
then
  chk_diags
  chk_ignite
fi

#===================================================================
# Check System Logfiles
#===================================================================

if (($LOGFILES))
then
  chk_logfiles
fi

#===================================================================
# Extract ERROR/WARNING messages
#===================================================================
f_extract_errors

if (($PASS))
then
  f_display_file /tmp/sysinfo.$$.sap
  print "\n\n" >> /tmp/sysinfo.$$.sapwarn
  f_display_file /tmp/sysinfo.$$.sapwarn

fi

#===================================================================
# Clean up end of HTML files if necessary
#===================================================================

if (($HTML))
then
  print "</BODY></HTML>" >> $LOGFILE_INDEX
  print "</BODY></HTML>" >> $LOGFILE_MAIN
  print "</BODY></NOFRAMES></FRAMESET></HTML>" >> $LOGFILE
  chmod 444 $LOGFILE_INDEX $LOGFILE_MAIN $LOGFILE
fi

#===================================================================
# END OF SCRIPT - SO LET'S GET OUT OF HERE!
#===================================================================
Debug "exit_code = ${exit_code}" 
exit ${exit_code}

